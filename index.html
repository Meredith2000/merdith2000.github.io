<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.zkwzkw.top","root":"/","images":"/images","scheme":"Muse","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="the web page to share my code">
<meta property="og:type" content="website">
<meta property="og:title" content="Meredith&#39;s blog">
<meta property="og:url" content="https://blog.zkwzkw.top/index.html">
<meta property="og:site_name" content="Meredith&#39;s blog">
<meta property="og:description" content="the web page to share my code">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="kaiwen zhou">
<meta property="article:tag" content="code">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.zkwzkw.top/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<title>Meredith's blog</title>
  

  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8f735d1ea69ea81de16638ad4504bd80";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Meredith's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">share my code</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">kaiwen zhou</p>
  <div class="site-description" itemprop="description">the web page to share my code</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.zkwzkw.top/2021/01/24/%E5%88%A9%E7%94%A8%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E8%A7%A3%E5%86%B3%E8%88%AA%E7%A9%BA%E9%80%89%E5%BA%A7%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kaiwen zhou">
      <meta itemprop="description" content="the web page to share my code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meredith's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/24/%E5%88%A9%E7%94%A8%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E8%A7%A3%E5%86%B3%E8%88%AA%E7%A9%BA%E9%80%89%E5%BA%A7%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">利用逻辑回归解决航空选座问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-24 22:23:26" itemprop="dateCreated datePublished" datetime="2021-01-24T22:23:26+08:00">2021-01-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="使用逻辑回归来训练航空选座系统模型"><a href="#使用逻辑回归来训练航空选座系统模型" class="headerlink" title="使用逻辑回归来训练航空选座系统模型"></a>使用逻辑回归来训练航空选座系统模型</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">&#x27;./data/plane.csv&#x27;</span>, low_memory=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h2 id="目前我遇到的问题"><a href="#目前我遇到的问题" class="headerlink" title="目前我遇到的问题"></a>目前我遇到的问题</h2><p>前段时间，我使用KNN来实现了对选座系统模型的训练，但是实现的效果并不理想，主要分为体现在下面几个方面:</p>
<h3 id="数据样本类别不平衡"><a href="#数据样本类别不平衡" class="headerlink" title="数据样本类别不平衡"></a>数据样本类别不平衡</h3><p>付费选座用户和非付费选座用户之间的比例关系</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">emd_lable2 = data.groupby(by=<span class="string">&#x27;emd_lable2&#x27;</span>).count().iloc[:, <span class="number">0</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>), dpi=<span class="number">100</span>)</span><br><span class="line">patches, texts, autotexts = plt.pie([emd_lable2[<span class="number">0</span>], emd_lable2[<span class="number">1</span>]], labels=[<span class="string">u&#x27;未付费&#x27;</span>, <span class="string">u&#x27;付费&#x27;</span>], autopct = <span class="string">&#x27;%3.2f%%&#x27;</span>)</span><br><span class="line">plt.legend(patches, [<span class="string">u&#x27;未付费&#x27;</span>, <span class="string">u&#x27;付费&#x27;</span>], loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;付费选座用户和非付费选座用户之间的比例关系&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/output_6_0.png" alt="output_6_0"></p>
<p>从上面的饼图中，我们可以清楚的看出，样本的类别分布极度不均衡，其中为付费的旅客占比达到93%，这样就导致大部分都是未付费的用户，这样，即使将预测值全部设定为未付费也能得到比较好的准确率，显然，这是不合理的，因为这其实是一种胡说（random guess）</p>
<h3 id="样本的特征值过多"><a href="#样本的特征值过多" class="headerlink" title="样本的特征值过多"></a>样本的特征值过多</h3><p>我们来看看给出的数据的特征值，总共是656列，在训练的过程中，将这么多的特征值融入到模型之中，毫无疑问会发生过拟合的现象，导致模型过于复杂，在测试集中的表现令人无法满意</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给出的特征值</span></span><br><span class="line">data.shape[<span class="number">1</span>]-<span class="number">1</span></span><br></pre></td></tr></table></figure>



<pre><code>656</code></pre>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决?"></a>如何解决?</h2><h3 id="使用SMOTE算法来解决样本类别不平衡"><a href="#使用SMOTE算法来解决样本类别不平衡" class="headerlink" title="使用SMOTE算法来解决样本类别不平衡"></a>使用SMOTE算法来解决样本类别不平衡</h3><p>使用SMOTE算法相比于普通的随机过采样（简单赋值），可以来避免过拟合，其增加了比例小的样本，但是这些特征不是原本收集的数据，而是“近似”出来的数据，可能会改变数据原本的特征，请看下面的对比（需要的注意的是，我下面选取的特征值是pax_fcny和pax_tax，我这里只是随便选的，展示一下效果）</p>
<p>没有经过SMOTE处理的原始数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, ax = plt.subplots(figsize=(<span class="number">6.5</span>, <span class="number">6.5</span>))</span><br><span class="line">sns.despine(f, left=<span class="literal">True</span>, bottom=<span class="literal">True</span>)</span><br><span class="line">sns.scatterplot(data=data, x=<span class="string">&#x27;pax_fcny&#x27;</span>, y=<span class="string">&#x27;pax_tax&#x27;</span>, hue=<span class="string">&#x27;emd_lable2&#x27;</span>)</span><br></pre></td></tr></table></figure>



<pre><code>&lt;AxesSubplot:xlabel=&#39;pax_fcny&#39;, ylabel=&#39;pax_tax&#39;&gt;</code></pre>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/output_14_1.png" alt="output_14_1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看0与1的个数</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">Counter(data[<span class="string">&#x27;emd_lable2&#x27;</span>])</span><br></pre></td></tr></table></figure>



<pre><code>Counter(&#123;0: 21957, 1: 1475&#125;)</code></pre>
<p>可以看出，分别有紫色和黄色的点，紫色的点明显多于黄色的点，下面进行SMOTE处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> imblearn.over_sampling <span class="keyword">import</span> SMOTE</span><br><span class="line"></span><br><span class="line">x_resampled, y_resampled = SMOTE().fit_resample(data.loc[:, <span class="string">&#x27;pax_fcny&#x27;</span>: <span class="string">&#x27;pax_tax&#x27;</span>], data[<span class="string">&#x27;emd_lable2&#x27;</span>])</span><br><span class="line"></span><br><span class="line">f, ax = plt.subplots(figsize=(<span class="number">6.5</span>, <span class="number">6.5</span>))</span><br><span class="line">sns.despine(f, left=<span class="literal">True</span>, bottom=<span class="literal">True</span>)</span><br><span class="line">sns.scatterplot(x=x_resampled.iloc[:, <span class="number">0</span>], y=x_resampled.iloc[:, <span class="number">1</span>], hue=y_resampled,)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>​<br><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/output_17_0.png" alt="output_17_0"><br>​    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看0与1的个数</span></span><br><span class="line">Counter(y_resampled)</span><br></pre></td></tr></table></figure>



<pre><code>Counter(&#123;0: 21957, 1: 21957&#125;)</code></pre>
<p>从上面的数据可以看出，目标值和特征值现在是平衡的了</p>
<h3 id="剔除没有必要的特征值"><a href="#剔除没有必要的特征值" class="headerlink" title="剔除没有必要的特征值"></a>剔除没有必要的特征值</h3><p>关于这一点，要通过专家来剔除</p>
<h2 id="如何评估"><a href="#如何评估" class="headerlink" title="如何评估?"></a>如何评估?</h2><h3 id="采用ROC曲线和AUC指标来判断是否优于随机猜测"><a href="#采用ROC曲线和AUC指标来判断是否优于随机猜测" class="headerlink" title="采用ROC曲线和AUC指标来判断是否优于随机猜测"></a>采用ROC曲线和AUC指标来判断是否优于随机猜测</h3><p>下面是混淆矩阵</p>
<p><img src="data:image/png;base64,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bLPNwhxzzBFmn312/eH7aYEFFggHHnhgeOyxx9pdZDj33HPDKqusEmadddYi7/PPP1+Plf3FL35RhJV9c++994YlllhCB/4nnnhi0MXhLHOwOiz2LRxzzDFh7bXXLtpj2WWX1ft99tknjB49OrS7T7z22mthvvnmC4h0brnlFqXDSy+9FDhdc5111hk0XfqbAROmkSNHBszaZ5lllv4mG1Q8c3BqYq1BZTaEiZ2JDCHxq1q0ibNsM1RZeGKWOs8884QXX3wxMHDgRHC77bbTAeXYY48NCy+8cNh+++1DO1dEDFZ33313QHfwxRdfaNU4ERAX6m+++Wa/q4ooYjADKnV//vnnNY92nNtiTjP7XYEGEXHDAVN//PHHtT3Yv7DccsuFGWaYIZxzzjlh6aWXDiuvvLKe5d4geUtBpg+gLWAoAF6kWVENlCkO5iwV+jyTmffffz+88847LdVloIneffddTfLRRx8NNGm14stA4eAUqKHAfffdF2VAiSeddFJNeBkPv/71r7UsyrvpppuKIi677LIi/JprrinCB3sjFkxRDAaimMQWWYk4Ib766qtRmFUR1teNzNbjT3/6076i9fp+tdVW0zrec889vcbrz8u5555b8+pP3L7iyOpD89p1112LqMJ0o4hfNFwYTRHejpvddttN85WJQ5GdMOgoK+Liua8bmQREYXbxr3/9a19Rm75/4YUXFI+ZZ565aZx2vph++um1vEcffbSd2XY8L1+JVIunVwIbW4nYtVNIpaaOK664YlHsddddp/esFpgdM3NDtJKuUIQZ6SzyT3/6U5EuvcGp5EMPPRRef/31gLiOfEyxiS4BkYLpgtJ0Y8aMCXfddVfN7PSGG24I119/fXj22WdD/SoCEQW43XHHHUEGtDQrvadsZvrCtIpTCAc64+6RqQSktGj0fiBhRpe0/aeZZpqw1FJLaTZXXnml0o4ykefzg7apiTF5EPbkk082xI06Q9cHH3ywodiSVd4jjzzSA21oWp8vNN9oo43CG2+8oWnq6YnYlDSsMupBRlxti6uvvlr7Bu9NzFQft6zn7I827jjb8gIrT4Fbb71VZ0innHJK6bimKxFmggay1FccWKEsssgicauttorCZKLoMuJ4442n75i5/uY3v4nrr79+lAEufuc739HZssj1LZsoA0rceOONNe3UU08dv/71r2ta8mDl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Aq8111yzlPLJdOedd44TTTSR4vHVr35Vy7zkkksGXd4666yjeU033XSDzqu/GXzyySdxhRVWKOg288wz99oPfvaznxVxp5566igMu79FDTje3HPPrWXtsMMOA07rCQZOgTDwJMMvxZJLLqmdUmarPSr/05/+NG6//fYa/sEHH8Q555xTB6YeETMIePvttyMfOAxEZooFxjKDjqussoqGwygNttlmGw175plnLKjX6+23367xyf+tt97qNW47X/7jH/+IsjLUsieZZJJ433331WQvKxKdEIDXcsstV/OuXQ/333+/MjAmIcAtt9wSt9pqqygr3EEXQR70wZtvvnnQeQ0kA+oEzex31113NUz+t7/9LX7ve98r4u22224N4/UWeMEFF8SXX365tyjFO1mZxdVXXz0+/fTTRZjflEcBZyJ90JYPgNk3Hwoz2XpgQLrzzjuL4P7MyovIFboRUVycYYYZig+dWbOBiPQ0fOGFF66ZbfJhQ5dTTjnFovZ6FdGXxp9vvvl6jdful2eddVZRr8suu6xh9iJeisymy2IiBx10kOKwxhprNCw/x8AXXnihoCv9QERHDashIryaeANlIqyO/+///i+KGLJh/h44tBRwnUgTMZ8FP/LIIwFZNrDYYotZsOpHvvGNbwRZpRRh3IjYJ4w77rg1YfYgIgCVB0822WQ99AjCfIIwrPDNb37Toje9/v73vw/jjz++vv/Nb34TJp544h5xZVUUJphggn7lh3x+s802U13OG2+8oXktv/zyegWv448/Xu9F/BNksCjKQj8EoOPoD7zzzjsaDf1DpwD8TzrpJC1u2mmnDRtssEHDomlLWVmFMWPG1LxH9i8zbtWJzTjjjGHdddcNIsIs4tCm6HmWXXbZICu5IKsBbQ/oafHQtRAOiJgzPPzwwwFcRKSluqUJJ5wwiMhU+wQ6A/oBtJXZe1EONw8++KCWIaupMM000wQRyel7WWmF0aNHa99be+21a9J8/PHHAR0XtKdfykqoRndB36aOwLzzzhtkwNa41KdRv0ozB9cUHnjgAdUfCjNOg8O5556rdRORYk24PdBGF154Yfjoo4/CHHPMoboi2gNA97b++uvrd0M/ExGa4oX+kbYS0bF+C7IKUpqKKCtAD9oEGk8++eSaD9+JDLV6D72p97vvvqvfB7Q3/aZG8L+BUWBoeVj1SzeRDTMtUQ4qwogP5pprroicHSAccYl8dDpjeumllzScP/lAdAUz6aSTRvkYVFyEyItZPPmQFlGEKHfj4osvXqRDxCJMK9rMlbJOPvlkFZchT0emLAxMZ3joKAzOP//8KB+ihqODkAHEXjW8CkOKrDDAyWaW6Do+//xzjS9KyiKvP//5zzV5HHPMMfquv7N3W+nUi5NqMm3zgyjSFUfaL6VTX8VAf2E4qsdZb731ogywmg+6lPfee0+TI3O3VaoMVoW+hbJWXnnlon+gPxPjgwIPGcwjeW655ZZFGKI+xIboaEiP7sb0BoRvuummccSIEVGMNvS9TDYUh+OOO071LKRJdSKI8I444gjVW6G7EOYSSUPfOeywwzQtq89ZZ521yO+HP/xhgQ84/vKXv+yVTMLUND56McrnB/4p8C1Q92uuuaaIk65EhLnF2WefXb+bJZZYIgrziDPNNFMU5qfZiMK+SIeuEXoLI498T5TH1fCGZpRvOkzqDAgDiYgxDUfqNWrUKH0m/M0339R4/tcaBVyc1QfdbPCgA4rFRzzxxBPjFFNMEetFMmLNpJ2SD8YGYLI+/PDDNXyllVbSkhjkyQuF/E033aRMhsGNsPnnn7/A5sorr9QwBncDEysRl0ELJS33YiUVGTSM4e23334RRTbvkLs3A9KIhVRE14M+xxjGiiuuWCRhACQflLf1YAMeBgZ9AQOvKdZThX1f6Qb7PhWl2ODZnzxtYDRRJZMBGDq0YLADGEQZuAiTlUFEVIauwxgLsnmDjTfeWOMxoDN4AzBwYy5iCadhtAP58Xvqqac0TKy59Pnuu+/WZxgHgy0gs/dCn5MyERu0U8b5xBNPaDpwvvHGGzW9WMkV5dGOsmrQQZzyxXpM4zT7MyYis36d8JAGJpVOouh/9E8YIUyAOCkT2X333TWMCQmAGJU49DtALCLjeOONp2HnnXdexMCDvkSfJR4/WfXFKaecMsoKXxnfbLPNpuGymtI8+EsNRvjuMAwhXwxnHAZHAWcivdAPCxQ+CjoqikFkvjYTxEIrBTol8VLrHgYLOiofrSmSjYmwKjEwpS8zU4PVVltN82MwM7j++us1jHKYoYl5ZRRz1Pjaa69FFLaEi9mkRt977731WcQElrzmCgOBCaBAN6ZnM2NWPAasjsg3VajbO5gp7y6QVVVfcM4552hcmF8nAYYKjvz6y0QYpBjcGZRstQnOIj4pBv17771Xq2EDHEzfwCYe6IAMWLWAgynWLZwZP+FmpcUgaYOtMREmLsSBEbEapO1S6zZ7nzIRW/UxwKdgkwIRV2rw2WefrXkz8BpcffXVGgYz7A2MibDaM6YFnhibAPQrJkswVoCVFO9TJkI9CMeoA9hiiy00zqKLLqrP/LFKJ12qExGTZg2jD/Kdicm9MhziN6M1ZZGPMfkzzzyT6A6DpIBvNuxF+vfss88Gk+PKhxBkGaw2/si65UOpSSkfvD6ndvrCOFQGLh+3yrCJIIOPxhMrKL2mYSKy0DD2Ytx66616L6uCIh6ydUCUjEFmoyoLxh6efQLER9bLHoejjz46yMASFllkkSADT5E+vWF/wlVXXaX7WmQ5H8SSpSjzww8/DMi7kVWjEwKQL6cALsQD5INPXzW8p06AzOYbvi8rUEQjRdbWlkVAkxvk69QdHYJMAIpYMpip3oAAWRUU4dyk+gvThZjeqiZi3YMMghpCWYCIElXOrw//+xPRmIaxb4d2OO2003RfUhonvZeVXqBNAcvX3ovVkt4KA1AditVPmKZFKXQ50KA/gI4OXYzpQmTCoX1DVhdBRE099mqk7SArpSCTIN2jg76DfVn1gJ6xHoxu7LHhe5DJXoG3MHaNbnEsrUzIVHeFPkQYV2n7VKy84XL98gsZLjUeQD1ldqmxRWwURHyl9ygb+Uj4OAxQXsJwZJYT2ERlAPOgI6PAY2Ob6AJ0Ax8KWpktaTQGYn7Ek1m/hjHAy+QgyP4FVSRafjALAOWuyIItOIjsW+8Z+GUGGmQloYpKBgqZdRXx7EZm2oEPHIDpLbTQQlo/lI8ATAglOvH44BkM2ViYAhvmGGRkBlswyPR9es9HCy6A1TF9X+Y9m81soIT+gwWUsAayIlCFL88MpPUA/foL6cBqacgfoB+xgQ5lM31NVhNBVqqqgLe46RWjCvoPUG+oYQwO5T35cx0sMHmh78tKT7OiH6LAZ7Of7A9RvHnBBl3AJh/cY5ggOhGdzIgFW9h8880JVoU6V9IYHXjuD1g59XHBEYYM/OpXv9IJYX0cfx44BZyJ9EIzUXbqW2ZYdECAQVmW3Hpvf+x+liW1WpakzIW4rAzo1KLvCCIfDj/5yU90QBUZriZnBQDAfJgNisiqWK1gDcYsC2C3vK0K0p2+7KbHqgVgpvriiy+q1UqzFQjxYITsOj/ggAP0x2pGFKy8Ujx4Zme1WbZQj3SmKiKVIKIAjS/iooI2GtDgT2TkykiZNYq4r0GM8oKoA5ZGANZD7FjvCxjUACya2JGdgg32rHBgTsagrJ3SuP2ZyRvjNibEgAnTBYzm7PbGWo62/vGPf6x9EIurvfbaKy2uuBc9WmG9Rx0aARZe7NY3CysmOQb1jMfC+7rC2Ix2WHxhhYhllYFNaGx1RJn0e5gekwwx8CjqbKsJ0jSireWF94h6aEZ3aEHfZiIAk4WWInKrT+7PA6SAM5EmBGOwsQ/cRABNourgxDs+IEReNiDQUTFvhAHhHoROzKqBmZuBrS5wlcKKhdmczXYRE9msDfEJjAQGkIqPMIE0EOW3rgr4wIjbzPSW2SjuWVjx8GO2aGXyYfGM6IZ8KEusyIpZJGVRB0Qm4CxWRlq8yMSDKD6LAdBw4gpjBIiPSWYK0ET236hpaRreznsTPdIeMGBjumkZzMgPPPBAfY/7DgY6GAYrAAPEKqxmWJnisoVB3iYX6SBs/SadETeb8ZvIywY+Vi8W1xgWjBc8aBPElDBuAHNcwOLpg/xBYxMbIvqyVQnvWTED0CEdnNPZfloXjdzkzwZ6Kx96pIxNNqg2XAlbnWHq9G8mFxZmTDt1BWN9xugCOkZb+z5SFI0JWjvwDhrQD+iDYoWoDI5VXYpvmoffD4ACQlyHBhTA7FYGCP2J7qBBjC+DsKoirnTQiMsF+SD1pXR0NbG0fIhXr+g0c1zMdWUgVyXkiP8pIIUpFYpyU77jPiIFTISFKWj5wgDUTBcrLkwXseLpD6CYRJkrs+oo+0RqkmCtA/62oRBrJeKiPMaSCECxSlripQpf3mE9hFsY3mGJUw9mwgm+0KsskJVXobCWAUst7djRDO4iRlHDCej/6quvKgq2MRKzbVndqXUR1kvUwwwJMEOVgVjDUG4DWBOJaFLDzKINyyQzpRVRZs2GTTOgQCmO2akwME1LOZgYk1bEjWp9JCsRVfSjYOb9GWecoWVa35DJiRpbEEjbYBhAPCyfcMNDXXHxwqZKjEYAER9pHMxkrd+KOLPAgTKbAZtvyT+1AGPTJm0JjTFhN0DJThjxMX+mXlhM8cyP/o81mD1jfSYr/iiMQ627COfbwgKRPohhC2FYZQkDtmL0isUh7+ijlMN7rL7IU8RYGufyyy/XOPTbRkYjNRn6Q68UgEM71FEAU02ZiRYdmoGEwboZYL5rHVoUyBqNAZEBFesdXInYIIuZK+4iDMx6SGZeavJLOB85+S0hpqRWLmaSmPRiiVUPmD6yt4M0/DAL7svGP82DwQPGhaVWI5DZmg6WNhBi2SOrrSIqljU2QFyQWGphUorpq9UdOsoKqEjHDdZl4Iw1ER98mYB7FqzNZMZc0Iqy2T+B1ZRZ0IEDuDD4QnMs9GTjpsZjoDfAlxiMh7rLik0HPEyKGeyoq6wcdKBkxzz7imgjGD4WfDZgy2pRaQQe0AnGA5Omn2CNBYOH/lgHgieMAsbFHgjeYcoNDvRXfpjsGrDvR4wrivqSL4xJVn8ahf0R0B1mA770IwZ79sIYc0zNvS1frkxmrM+Rr2xILV4zeZEVbvEsIjOdYFme1MMsEen/1h4wEZi9MWEYC+0A07CJEvtCSMsz+XElHWUA4hQy8i1BC8qhjWC6sqpWGsrKXeOJCFrbjXgwl9QcWyP4X78pMBYxB7BwGTZR5SMv5OHS0XooKFNCsMxGXo2S2WS1yIfZ6Yy+BPk51lvoR7D84Vn8AGkWiDEQr8ggUoiUkIFjXSMzqSI/IiM2QGTQCH7729+q+ApRC3i0G2QAVrEW1kHslq4HRHGI1hopzhGHUU9wq8efcGiD8pgd9p0AaIV1Ge2G8QLtIQNSw6LpB8j3uWIQQR1aBdoP3ZkMbjVZQAN2WNN30J0hp8dKSwbImnjQEbzRXwnjqnnX2wP5ITaEvvVWds3SsbMekSi40v8bASIlaIluBXz7AssTPFJ6028QAVu/JV/qiViR7wJAd0N6DEqgE/e8wyoLg4NGQJtZOeRPukZ44rGhvk0a5edhjSngTKQxXQYViusQBhzk5lgxGaBHQKGOsjfVZdh7vzoFnAJOgdwo4Ir1ElqM2Q4zJFYnpiikGHwrAVhoOTgFnAJOgW6ggK9ESmpF2YEcZBe7ij9E8anikEsvvVQPqzJ7+pKK9mydAk4Bp0DHKOBMpERSI1M2M0xk2JgA1+sESizes3YKOAWcAqVTwJlI6ST2ApwCTgGnQPdSwHUi3du2XjOngFPAKVA6BZyJlE5iL8Ap4BRwCnQvBZyJdG/bes2cAk4Bp0DpFHAmUjqJvQCngFPAKdC9FHAm0r1t6zVzCjgFnAKlU8CZSOkk9gKcAk4Bp0D3UsCZSPe2rdfMKeAUcAqUTgFnIqWT2AtwCjgFnALdSwFnIt3btl4zp4BTwClQOgWciZROYi/AKeAUcAp0LwWciXRv23rNnAJOAadA6RT4f+teFlDq4bnpAAAAAElFTkSuQmCC" alt="混淆矩阵"></p>
<p>通常我们评估模型的时候分为一下三个方面</p>
<ul>
<li>准确率：(TP+TN)/(TP+FN+FP+TN)</li>
<li>精确率：(TP)/(TP+FP)</li>
<li>召回率：(TP)/(TP+FN)</li>
</ul>
<p>但是在数据样本类别不平衡的状态下，即使这三个数据再高，也无法保证模型的可用性，所有我们要引入AUC指标</p>
<p>具体论文可以参看这篇文章：<a target="_blank" rel="noopener" href="https://www.researchgate.net/publication/226755026_Data_Mining_for_Imbalanced_Datasets_An_Overview">https://www.researchgate.net/publication/226755026_Data_Mining_for_Imbalanced_Datasets_An_Overview</a></p>
<h2 id="逻辑回归实现航空选座"><a href="#逻辑回归实现航空选座" class="headerlink" title="逻辑回归实现航空选座"></a>逻辑回归实现航空选座</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br></pre></td></tr></table></figure>
<h3 id="数据基本处理"><a href="#数据基本处理" class="headerlink" title="数据基本处理"></a>数据基本处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确定特征值和目标值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;没有经过SMOTE的算法</span></span><br><span class="line"><span class="string">x = data.loc[:, &#x27;pax_fcny&#x27;: &#x27;pax_tax&#x27;]    # 特征值</span></span><br><span class="line"><span class="string">y = data[&#x27;emd_lable2&#x27;]         # 目标值</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">x = x_resampled</span><br><span class="line">y = y_resampled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割数据</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=<span class="number">2</span>, test_size=<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="特征工程（标准化）"><a href="#特征工程（标准化）" class="headerlink" title="特征工程（标准化）"></a>特征工程（标准化）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化转换器</span></span><br><span class="line">transfer = StandardScaler()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对特征值进行标准化</span></span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.fit_transform(x_test)</span><br></pre></td></tr></table></figure>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用逻辑回归</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化估计器</span></span><br><span class="line">estimator = LogisticRegression()</span><br><span class="line">estimator.fit(x_train, y_train)</span><br></pre></td></tr></table></figure>



<pre><code>LogisticRegression()</code></pre>
<h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导包</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report, roc_auc_score</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 精确率/召回率指标评价</span></span><br><span class="line">ret = classification_report(y_test, estimator.predict(x_test), labels=(<span class="number">0</span>, <span class="number">1</span>), target_names=(<span class="string">&#x27;未付费&#x27;</span>, <span class="string">&#x27;付费&#x27;</span>))</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>
<pre><code>              precision    recall  f1-score   support

         未付费       0.65      0.09      0.15      4291
          付费       0.52      0.95      0.68      4492

    accuracy                           0.53      8783
   macro avg       0.59      0.52      0.42      8783
weighted avg       0.58      0.53      0.42      8783</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AUC指标计算</span></span><br><span class="line"></span><br><span class="line">y_pre = estimator.predict(x_test)</span><br><span class="line">roc_auc_score(y_test, y_pre)</span><br></pre></td></tr></table></figure>



<pre><code>0.5212221193149404</code></pre>
<p>根据AUC指标可以看出，这个模型的整体状态是由于random guess的</p>
<h2 id="总结与对比"><a href="#总结与对比" class="headerlink" title="总结与对比"></a>总结与对比</h2><p>虽然在本次的模型中，传统的指标看上去没有那么出彩，但是至少这个模型的是优于之前的模型的，表明之前的机器学习是有效学习，但是从指标中也可以看出，未付费的回调率和稳定性是非常低的，接下来的阶段，要针对这两个指标进行调优</p>
<p>下面我想与没有经过SMOTE算法进行比较（我这里主要对比AUC指标）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特征值和目标值没有经过SMOTE算法</span></span><br><span class="line">x = data.loc[:, <span class="string">&#x27;pax_fcny&#x27;</span>: <span class="string">&#x27;pax_tax&#x27;</span>]    <span class="comment"># 特征值</span></span><br><span class="line">y = data[<span class="string">&#x27;emd_lable2&#x27;</span>]         <span class="comment"># 目标值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割数据</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=<span class="number">2</span>, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化转换器</span></span><br><span class="line">transfer = StandardScaler()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对特征值进行标准化</span></span><br><span class="line">x_train = transfer.fit_transform(x_train)</span><br><span class="line">x_test = transfer.fit_transform(x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用逻辑回归</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化估计器</span></span><br><span class="line">estimator = LogisticRegression()</span><br><span class="line">estimator.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 精确率/召回率指标评价</span></span><br><span class="line">ret = classification_report(y_test, estimator.predict(x_test), labels=(<span class="number">0</span>, <span class="number">1</span>), target_names=(<span class="string">&#x27;未付费&#x27;</span>, <span class="string">&#x27;付费&#x27;</span>))</span><br><span class="line">print(<span class="string">&#x27;精确率/召回率指标评价\n&#x27;</span>, ret)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;预测的情况统计\n&#x27;</span>, Counter(estimator.predict(x_test)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># AUC指标计算</span></span><br><span class="line"></span><br><span class="line">y_pre = estimator.predict(x_test)</span><br><span class="line">roc_auc_score(y_test, y_pre)</span><br></pre></td></tr></table></figure>
<pre><code>精确率/召回率指标评价
               precision    recall  f1-score   support

         未付费       0.94      1.00      0.97      4406
          付费       0.00      0.00      0.00       281

    accuracy                           0.94      4687
   macro avg       0.47      0.50      0.48      4687
weighted avg       0.88      0.94      0.91      4687

预测的情况统计
 Counter(&#123;0: 4687&#125;)


/usr/local/lib/python3.9/site-packages/sklearn/metrics/_classification.py:1245: UndefinedMetricWarning: Precision and F-score are ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))
/usr/local/lib/python3.9/site-packages/sklearn/metrics/_classification.py:1245: UndefinedMetricWarning: Precision and F-score are ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))
/usr/local/lib/python3.9/site-packages/sklearn/metrics/_classification.py:1245: UndefinedMetricWarning: Precision and F-score are ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))





0.5</code></pre>
<p>从这里可以看出，虽然整个模型未付费的精确率和召回率很高，但是付费的精确率和召回率为0，AUC指标也为0，而且整个模型遇到任何情况都会输出0，说明这是一个random guess，也就是计算机在bullshit</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.zkwzkw.top/2021/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kaiwen zhou">
      <meta itemprop="description" content="the web page to share my code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meredith's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机网络习题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-12 11:07:55" itemprop="dateCreated datePublished" datetime="2021-01-12T11:07:55+08:00">2021-01-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>计算机网络课后习题及重要知识点</p>
<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="分组交换和电路交换的时延"><a href="#分组交换和电路交换的时延" class="headerlink" title="分组交换和电路交换的时延"></a>分组交换和电路交换的时延</h3><p>分组交换：</p>
<ul>
<li>发送时延</li>
<li>处理时延（经过节点数*单个节点的处理时延）</li>
<li>传播时延</li>
<li>排队时延</li>
</ul>
<p>电路交换：</p>
<ul>
<li>发送时延</li>
<li>传播时延</li>
<li>建立链接时延</li>
</ul>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-11%20%E4%B8%8A%E5%8D%8810.36.43.png" alt="截屏2021-01-11 上午10.36.43"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-11%20%E4%B8%8A%E5%8D%8810.44.03.png" alt="截屏2021-01-11 上午10.44.03"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-11%20%E4%B8%8A%E5%8D%8810.44.54.png" alt="截屏2021-01-11 上午10.44.54"></p>
<h3 id="网络利用率"><a href="#网络利用率" class="headerlink" title="网络利用率"></a>网络利用率</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-11%20%E4%B8%8A%E5%8D%8810.45.57.png" alt="截屏2021-01-11 上午10.45.57"></p>
<p>D 表示当前网络的时延</p>
<p>D0表示网络空闲时的时延</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-11%20%E4%B8%8A%E5%8D%8810.47.02.png" alt="截屏2021-01-11 上午10.47.02"></p>
<h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><h3 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-11%20%E4%B8%8A%E5%8D%8810.54.00.png" alt="截屏2021-01-11 上午10.54.00"></p>
<h3 id="码分多址CDMA"><a href="#码分多址CDMA" class="headerlink" title="码分多址CDMA"></a>码分多址CDMA</h3><h4 id="题目：码分多址CDMA为什么可以使所有用户在同样的时间使用同样的频带进行通信而不会互相干扰？这种复用方法有何优缺点？"><a href="#题目：码分多址CDMA为什么可以使所有用户在同样的时间使用同样的频带进行通信而不会互相干扰？这种复用方法有何优缺点？" class="headerlink" title="题目：码分多址CDMA为什么可以使所有用户在同样的时间使用同样的频带进行通信而不会互相干扰？这种复用方法有何优缺点？"></a>题目：<strong>码分多址CDMA为什么可以使所有用户在同样的时间使用同样的频带进行通信而不会互相干扰？这种复用方法有何优缺点？</strong></h4><p>各用户使用经过特殊挑选的相互正交的不同码型，因此彼此不会造成干扰。<br>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。占用较大的带宽。</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-11%20%E4%B8%8A%E5%8D%8810.57.03.png" alt="截屏2021-01-11 上午10.57.03"></p>
<p>将收到的码片与四个站的码片做内积再除以个数：</p>
<ul>
<li>1 表示发送的是1</li>
<li>0 表示没有发送</li>
<li>-1 表示发送的是0</li>
</ul>
<h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h2><h3 id="CRC循环冗余码"><a href="#CRC循环冗余码" class="headerlink" title="CRC循环冗余码"></a>CRC循环冗余码</h3><h4 id="题目：要发送的数据为1101011011。采用CRC的生成多项式是P（X）-X-4-X-1。试求应添加在数据后面的余数。数据在传输过程中最后一个1变成了0，问接收端能否发现？若数据在传输过程中最后两个1都变成了0，问接收端能否发现？采用CRC检验后，数据链路层的传输是否就变成了可靠的传输？"><a href="#题目：要发送的数据为1101011011。采用CRC的生成多项式是P（X）-X-4-X-1。试求应添加在数据后面的余数。数据在传输过程中最后一个1变成了0，问接收端能否发现？若数据在传输过程中最后两个1都变成了0，问接收端能否发现？采用CRC检验后，数据链路层的传输是否就变成了可靠的传输？" class="headerlink" title="题目：要发送的数据为1101011011。采用CRC的生成多项式是P（X）=X^4+X+1。试求应添加在数据后面的余数。数据在传输过程中最后一个1变成了0，问接收端能否发现？若数据在传输过程中最后两个1都变成了0，问接收端能否发现？采用CRC检验后，数据链路层的传输是否就变成了可靠的传输？"></a>题目：<strong>要发送的数据为1101011011。采用CRC的生成多项式是P（X）=X^4+X+1。试求应添加在数据后面的余数。数据在传输过程中最后一个1变成了0，问接收端能否发现？若数据在传输过程中最后两个1都变成了0，问接收端能否发现？采用CRC检验后，数据链路层的传输是否就变成了可靠的传输？</strong></h4><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/image-20210111122408924.png" alt="image-20210111122408924"></p>
<p>仅仅采用了CRC检验，缺重传机制，数据链路层的传输还不是可靠的传输</p>
<h3 id="PPP实现透明传输"><a href="#PPP实现透明传输" class="headerlink" title="PPP实现透明传输"></a>PPP实现透明传输</h3><p>字符填充</p>
<table>
<thead>
<tr>
<th>原始数据</th>
<th>字符填充之后的数据</th>
</tr>
</thead>
<tbody><tr>
<td>7D</td>
<td>7D 5D</td>
</tr>
<tr>
<td>7E</td>
<td>7D 5E</td>
</tr>
<tr>
<td>&lt; 20</td>
<td>7D 原来的字符</td>
</tr>
</tbody></table>
<p>零比特填充</p>
<p>在连续的五个1之后加上一个0</p>
<h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><p>最短帧长实际上就是<strong>两倍争用期时所发送的帧的长度</strong></p>
<p>在以太网协议中，规定：<strong>最短有效帧长时64字节</strong></p>
<p>常见的<strong>以太网争用期</strong>：</p>
<ul>
<li>10Mbit/s 的网络中的争用期是 <strong>51.2us</strong></li>
<li>100Mbit/s 的网络中的争用期是 <strong>5.12us</strong></li>
</ul>
<p>在过了争用期之后，就不可能会发生碰撞</p>
<p>PPP协议在发送的时候要在头部封装一个5个字节，在尾部封装3个字节，也就是一共<strong>消耗8个字节的大小</strong>，而整个帧的长度在以太网中不能小于64字节</p>
<p>同时在使用CSMA/CD时，要在前面和后面封装8个字节的大小</p>
<p>在r随机数选定之后，要等待<strong>r倍的争用期</strong>才能重新发送数据</p>
<h4 id="题目：在上题中的站点A和B在t-0时同时发送了数据帧。当t-255比特时间，A和B同时检测到发生了碰撞，并且在t-255-48-273比特时间完成了干扰信号的传输。A和B在CSMA-CD算法中选择不同的r值退避。假定A和B选择的随机数分别是rA-0和rB-1。试问A和B各在什么时间开始重传其数据帧？A重传的数据帧在什么时间到达B？A重传的数据会不会和B重传的数据再次发生碰撞？B会不会在预定的重传时间停止发送数据？"><a href="#题目：在上题中的站点A和B在t-0时同时发送了数据帧。当t-255比特时间，A和B同时检测到发生了碰撞，并且在t-255-48-273比特时间完成了干扰信号的传输。A和B在CSMA-CD算法中选择不同的r值退避。假定A和B选择的随机数分别是rA-0和rB-1。试问A和B各在什么时间开始重传其数据帧？A重传的数据帧在什么时间到达B？A重传的数据会不会和B重传的数据再次发生碰撞？B会不会在预定的重传时间停止发送数据？" class="headerlink" title="题目：在上题中的站点A和B在t=0时同时发送了数据帧。当t=255比特时间，A和B同时检测到发生了碰撞，并且在t=255+48=273比特时间完成了干扰信号的传输。A和B在CSMA/CD算法中选择不同的r值退避。假定A和B选择的随机数分别是rA=0和rB=1。试问A和B各在什么时间开始重传其数据帧？A重传的数据帧在什么时间到达B？A重传的数据会不会和B重传的数据再次发生碰撞？B会不会在预定的重传时间停止发送数据？"></a>题目：<strong>在上题中的站点A和B在t=0时同时发送了数据帧。当t=255比特时间，A和B同时检测到发生了碰撞，并且在t=255+48=273比特时间完成了干扰信号的传输。A和B在CSMA/CD算法中选择不同的r值退避。假定A和B选择的随机数分别是rA=0和rB=1。试问A和B各在什么时间开始重传其数据帧？A重传的数据帧在什么时间到达B？A重传的数据会不会和B重传的数据再次发生碰撞？B会不会在预定的重传时间停止发送数据？</strong></h4><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/image-20210111144723443.png" alt="image-20210111144723443"></p>
<p>注意：</p>
<p><strong>干扰信号是广播</strong>，其占用信道的时间为单程信道的比特时间</p>
<p>双方在干扰信号发送之后开始进行退避，退避r倍的争用期</p>
<p>退避结束之后，要开始进行监听，监听的时间为<strong>最小帧间距</strong>，<strong>在以太网中是默认是96bit</strong>，如果在这段时间之内没有发现信道被占用的情况就开始发送数据</p>
<p>第i次重传失败的概率是<br>$$<br>P_i = (0.5)^k, \qquad k = min[i, 10]<br>$$</p>
<h3 id="集线器和交换机"><a href="#集线器和交换机" class="headerlink" title="集线器和交换机"></a>集线器和交换机</h3><p><strong>集线器是物理层的设备</strong>，其特点是是一个半双工，各设备平分带宽，且会组成一个更大的碰撞域，需要CSMA/CD来检测碰撞<br><strong>交换器是数据链路层的设备</strong>，其特点是一个全双工，各设备独享带宽，且不会形成碰撞域，不会产生碰撞</p>
<h4 id="题目：以太网交换机有何特点？用它怎样组成虚拟局域网？"><a href="#题目：以太网交换机有何特点？用它怎样组成虚拟局域网？" class="headerlink" title="题目：以太网交换机有何特点？用它怎样组成虚拟局域网？"></a>题目：<strong>以太网交换机有何特点？用它怎样组成虚拟局域网？</strong></h4><p>特点：以太网交换机实质就是一个多端口的的网桥，它工作在数据链路层上。每一个端口都直接与一个主机或一个集线器相连，并且是全双工工作。它能同时连通多对端口，使每一对通信能进行无碰撞地传输数据。在通信时是独占而不是和其他网络用户共享传输媒体的带宽。</p>
<p>怎么组成VLAN：VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组。这些网段具有某些共同的需求。虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为 VLAN 标记 (tag)，用来指明发送该帧的工作站属于哪一个虚拟局域网。</p>
<h3 id="交换机交换表的更新"><a href="#交换机交换表的更新" class="headerlink" title="交换机交换表的更新"></a>交换机交换表的更新</h3><table>
<thead>
<tr>
<th>动作</th>
<th>交换表的状态（地址-&gt;接口）</th>
<th>向哪些接口转发帧</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>A发送帧给D</td>
<td>写入 A-&gt;1</td>
<td>1, 2, 3, 4, 5, 6</td>
<td>一开始，交换表中没有D的MAC地址，需要<strong>广播</strong>，并记录下A的地址与接口</td>
</tr>
<tr>
<td>D发送帧给A</td>
<td>写入 D-&gt;4</td>
<td>1</td>
<td>交换表中存在A的信息</td>
</tr>
<tr>
<td>E发送帧给A</td>
<td>写入 E-&gt;5</td>
<td>1</td>
<td>交换表中存在A的信息</td>
</tr>
<tr>
<td>A发送帧给E</td>
<td>不变</td>
<td>5</td>
<td>交换表中存在E的信息</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>交换表中不存在就广播</li>
<li>在每次寻找接口的时候，如果交换表中没有改请求的MAC地址与接口的信息，则写入交换表中</li>
</ul>
<h3 id="以太网的升级"><a href="#以太网的升级" class="headerlink" title="以太网的升级"></a>以太网的升级</h3><h4 id="题目：10Mb-s以太网升级到100Mb-s、1Gb-S和10Gb-s时，都需要解决哪些技术问题？为什么以太网能够在发展的过程中淘汰掉自己的竞争对手，并使自己的应用范围从局域网一直扩展到城域网和广域网？"><a href="#题目：10Mb-s以太网升级到100Mb-s、1Gb-S和10Gb-s时，都需要解决哪些技术问题？为什么以太网能够在发展的过程中淘汰掉自己的竞争对手，并使自己的应用范围从局域网一直扩展到城域网和广域网？" class="headerlink" title="题目：10Mb/s以太网升级到100Mb/s、1Gb/S和10Gb/s时，都需要解决哪些技术问题？为什么以太网能够在发展的过程中淘汰掉自己的竞争对手，并使自己的应用范围从局域网一直扩展到城域网和广域网？"></a>题目：<strong>10Mb/s以太网升级到100Mb/s、1Gb/S和10Gb/s时，都需要解决哪些技术问题？为什么以太网能够在发展的过程中淘汰掉自己的竞争对手，并使自己的应用范围从局域网一直扩展到城域网和广域网？</strong></h4><p>技术问题：使参数a保持为较小的数值，可通过减小最大电缆长度或增大帧的最小长度<br>在100mb/s的以太网中采用的方法是保持最短帧长不变，但将一个网段的最大电缆的度减小到100m，帧间时间间隔从原来9.6微秒改为现在的0.96微秒<br>吉比特以太网仍保持一个网段的最大长度为100m，但采用了“载波延伸”的方法，使最短帧长仍为64字节（这样可以保持兼容性）、同时将争用时间增大为512字节。并使用“分组突发”减小开销<br>10吉比特以太网的帧格式与10mb/s，100mb/s和1Gb/s以太网的帧格式完全相同<br>吉比特以太网还保留标准规定的以太网最小和最大帧长，这就使用户在将其已有的以太网进行升级时，仍能和较低速率的以太网很方便地通信。<br>由于数据率很高，吉比特以太网不再使用铜线而只使用光纤作为传输媒体，它使用长距离（超过km）的光收发器与单模光纤接口，以便能够工作在广域网。</p>
<h2 id="第四章-网络层"><a href="#第四章-网络层" class="headerlink" title="第四章 网络层"></a>第四章 网络层</h2><h3 id="转发器、网桥、路由器和网关有何区别"><a href="#转发器、网桥、路由器和网关有何区别" class="headerlink" title="转发器、网桥、路由器和网关有何区别"></a>转发器、网桥、路由器和网关有何区别</h3><p> 中间设备又称为中间系统或中继(relay)系统。</p>
<p>物理层中继系统：转发器(repeater)。</p>
<p>数据链路层中继系统：网桥或桥接器(bridge)。</p>
<p>网络层中继系统：路由器(router)。</p>
<p>网桥和路由器的混合物：桥路器(brouter)。</p>
<p>网络层以上的中继系统：网关(gateway)。  </p>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>ip地址的分类</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-11%20%E4%B8%8B%E5%8D%883.43.39.png" alt="截屏2021-01-11 下午3.43.39"></p>
<table>
<thead>
<tr>
<th>网络名</th>
<th>网络号</th>
<th>子网掩码</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>A类地址</td>
<td>1～126</td>
<td>255.0.0.0</td>
<td></td>
</tr>
<tr>
<td>B类地址</td>
<td>128.0～191.255</td>
<td>255.255.0.0</td>
<td></td>
</tr>
<tr>
<td>C类地址</td>
<td>192.0.0～223.255.255</td>
<td>255.255.255.0</td>
<td></td>
</tr>
<tr>
<td></td>
<td>127</td>
<td>255.0.0.0</td>
<td>用于本地软件回环测试</td>
</tr>
<tr>
<td>D类地址</td>
<td>224~239</td>
<td></td>
<td></td>
</tr>
<tr>
<td>E类地址</td>
<td>240~255</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/1440532-20180912093223517-341420925.png" alt="1440532-20180912093223517-341420925"></p>
<p>注意：主机号一般不会全0或者是全1</p>
<h4 id="题目：IP地址分为几类？各如何表示？IP地址的主要特点是什么？"><a href="#题目：IP地址分为几类？各如何表示？IP地址的主要特点是什么？" class="headerlink" title="题目：IP地址分为几类？各如何表示？IP地址的主要特点是什么？"></a>题目：<strong>IP地址分为几类？各如何表示？IP地址的主要特点是什么？</strong></h4><p>分为ABCDE 5类</p>
<p>每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号 host-id，它标志该主机（或路由器）。各类地址的网络号字段net-id分别为1，2，3，0，0字节；主机号字段host-id分别为3字节、2字节、1字节、4字节、4字节。</p>
<p><strong>特点</strong>：</p>
<ol>
<li>IP 地址是一种分等级的地址结构。分两个等级的好处是：第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li>
<li>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口。当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为多归属主机(multihomed host)。由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的 IP 地址。 </li>
<li>用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。</li>
<li>所有分配到网络号 net-id 的网络，范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</li>
</ol>
<h4 id="题目：试简单说明下列协议的作用：IP、ARP、RARP和ICMP。"><a href="#题目：试简单说明下列协议的作用：IP、ARP、RARP和ICMP。" class="headerlink" title="题目：试简单说明下列协议的作用：IP、ARP、RARP和ICMP。"></a>题目：<strong>试简单说明下列协议的作用：IP、ARP、RARP和ICMP。</strong></h4><p> <strong>IP协议</strong>：实现网络互连。使参与互连的性能各异的网络从用户看起来好像是一个统一的网络。网际协议IP是TCP/IP体系中两个最主要的协议之一，与IP协议配套使用的还有四个协议。</p>
<p><strong>ARP协议</strong>：是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。    <strong>ip-&gt;MAC</strong></p>
<p><strong>RARP</strong>：是解决同一个局域网上的主机或路由器的硬件地址和IP地址的映射问题。    <strong>MAC-&gt;ip</strong></p>
<p><strong>网际控制报文协议 ICMP</strong>：提供差错报告和询问报文，以提高IP数据交付成功的机会    Ping命令</p>
<p><strong>因特网组管理协议 IGMP</strong>：用于探寻、转发本局域网内的组成员关系。</p>
<h4 id="题目：有人认为：“ARP协议向网络层提供了转换地址的服务，因此ARP应当属于数据链路层。”这种说法为什么是错误的？"><a href="#题目：有人认为：“ARP协议向网络层提供了转换地址的服务，因此ARP应当属于数据链路层。”这种说法为什么是错误的？" class="headerlink" title="题目：有人认为：“ARP协议向网络层提供了转换地址的服务，因此ARP应当属于数据链路层。”这种说法为什么是错误的？"></a>题目：有人认为：“ARP协议向网络层提供了转换地址的服务，因此ARP应当属于数据链路层。”这种说法为什么是错误的？</h4><p>因为ARP本身是网络层的一部分，ARP协议为IP协议提供了转换地址的服务，数据链路层使用硬件地址而不使用IP地址，无需ARP协议数据链路层本身即可正常运行。因此ARP不再数据链路层。</p>
<h4 id="题目：试解释为什么ARP高速缓存每存入一个项目就要设置10-20分钟的超时计时器。这个时间设置的太大或太小会出现什么问题？"><a href="#题目：试解释为什么ARP高速缓存每存入一个项目就要设置10-20分钟的超时计时器。这个时间设置的太大或太小会出现什么问题？" class="headerlink" title="题目：试解释为什么ARP高速缓存每存入一个项目就要设置10~20分钟的超时计时器。这个时间设置的太大或太小会出现什么问题？"></a>题目：试解释为什么ARP高速缓存每存入一个项目就要设置10~20分钟的超时计时器。这个时间设置的太大或太小会出现什么问题？</h4><p>考虑到IP地址和Mac地址均有可能是变化的（更换网卡，或动态主机配置）10－20分钟更换一块网卡是合理的。超时时间太短会使ARP请求和响应分组的通信量太频繁，而超时时间太长会使更换网卡后的主机迟迟无法和网络上的其他主机通信。</p>
<h4 id="题目：至少举出两种不需要发送ARP请求分组的情况（即不需要请求将某个目的IP地址解析为相应的硬件地址）。"><a href="#题目：至少举出两种不需要发送ARP请求分组的情况（即不需要请求将某个目的IP地址解析为相应的硬件地址）。" class="headerlink" title="题目：至少举出两种不需要发送ARP请求分组的情况（即不需要请求将某个目的IP地址解析为相应的硬件地址）。"></a>题目：至少举出两种不需要发送ARP请求分组的情况（即不需要请求将某个目的IP地址解析为相应的硬件地址）。</h4><p>在源主机的ARP高速缓存中已经有了该目的IP地址的项目；</p>
<p>源主机发送的是广播分组；源主机和目的主机使用点对点链路。19.主机A发送IP数据报给主机B，途中经过了5个路由器。试问在IP数据报的发送过程中总共使用了几次ARP？  6次，主机用一次，每个路由器各使用一次。</p>
<h4 id="题目：试说明IP地址与硬件地址的区别，为什么要使用这两种不同的地址？"><a href="#题目：试说明IP地址与硬件地址的区别，为什么要使用这两种不同的地址？" class="headerlink" title="题目：试说明IP地址与硬件地址的区别，为什么要使用这两种不同的地址？"></a>题目：试说明IP地址与硬件地址的区别，为什么要使用这两种不同的地址？</h4><p><strong>IP 地址</strong>就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。从而把整个因特网看成为一个单一的、抽象的网络在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。<br><strong>MAC地址</strong>在一定程度上与硬件一致，基于物理、能够标识具体的链路通信对象、IP地址给予逻辑域的划分、不受硬件限制。</p>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>使用子网掩码(subnet mask)可以找出 IP 地址中的子网部分。 </p>
<p>IP与子网掩码相与会获得子网的网络地址，其会屏蔽主机号</p>
<p>根据子网掩码可以知道网络中能够分配的最大主机数目（设掩码中有n个0，那么最大主机数 = 2^n - 2 台主机，全0或者全1不能分配）</p>
<p>注意：即使不连续的子网掩码也可能是有效的，但是RFC 950中不推荐这么使用，比如说255.255.0.255 </p>
<blockquote>
<p>Since the bits that identify the subnet are specified by a bitmask, <strong>they need not be adjacent in the address</strong>.<br>原文地址: <a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc950.html">https://www.rfc-editor.org/rfc/rfc950.html</a></p>
</blockquote>
<h3 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h3><p>IP数据报小于等于1500字节</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-11%20%E4%B8%8B%E5%8D%885.23.27.png" alt="截屏2021-01-11 下午5.23.27"></p>
<p><strong>ip数据报首部为20字节，且数据部分必须是8字节的整数倍</strong></p>
<p><strong>ip数据报的长度 = 数据帧的长度（数据长度）</strong></p>
<h4 id="题目：一个3200位长的TCP报文传到IP层，加上160位的首部后成为数据报。下面的互联网由两个局域网通过路由器连接起来。但第二个局域网所能传送的最长数据帧中的数据部分只有1200位。因此数据报在路由器必须进行分片。试问第二个局域网向其上层要传送多少比特的数据（这里的“数据”当然指的是局域网看见的数据）"><a href="#题目：一个3200位长的TCP报文传到IP层，加上160位的首部后成为数据报。下面的互联网由两个局域网通过路由器连接起来。但第二个局域网所能传送的最长数据帧中的数据部分只有1200位。因此数据报在路由器必须进行分片。试问第二个局域网向其上层要传送多少比特的数据（这里的“数据”当然指的是局域网看见的数据）" class="headerlink" title="题目：一个3200位长的TCP报文传到IP层，加上160位的首部后成为数据报。下面的互联网由两个局域网通过路由器连接起来。但第二个局域网所能传送的最长数据帧中的数据部分只有1200位。因此数据报在路由器必须进行分片。试问第二个局域网向其上层要传送多少比特的数据（这里的“数据”当然指的是局域网看见的数据）"></a>题目：一个3200位长的TCP报文传到IP层，加上160位的首部后成为数据报。下面的互联网由两个局域网通过路由器连接起来。但第二个局域网所能传送的最长数据帧中的数据部分只有1200位。因此数据报在路由器必须进行分片。试问第二个局域网向其上层要传送多少比特的数据（这里的“数据”当然指的是局域网看见的数据）</h4><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/image-20210111170510775.png" alt="image-20210111170510775"></p>
<p>在分片时，MF字段为1，表示之后还有分片，最后一个分片为MF = 0</p>
<h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><table>
<thead>
<tr>
<th>目的网络</th>
<th>子网掩码</th>
<th>下一跳</th>
</tr>
</thead>
<tbody><tr>
<td>128.96.39.0</td>
<td>255.255.255.128</td>
<td>接口m0</td>
</tr>
<tr>
<td>128.96.39.128</td>
<td>255.255.255.128</td>
<td>接口m1</td>
</tr>
<tr>
<td>128.96.40.0</td>
<td>255.255.255.128</td>
<td>R2</td>
</tr>
<tr>
<td>192.4.153.0</td>
<td>255.255.255.192</td>
<td>R3</td>
</tr>
<tr>
<td>*（默认）</td>
<td>——</td>
<td>R4</td>
</tr>
</tbody></table>
<p>路由器收到的分组的目的地址和子网掩码相与，要是等于相应的目的网络，就进行下一跳，如果不匹配，则与下面的子网掩码相与，要是全部不匹配则使用默认的</p>
<p><strong>最长匹配原则</strong>：如果多个网络都与路由表中的匹配，那么就匹配子网掩码最长的那一个</p>
<h4 id="题目：路由表的更新"><a href="#题目：路由表的更新" class="headerlink" title="题目：路由表的更新"></a>题目：路由表的更新</h4><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-11%20%E4%B8%8B%E5%8D%888.23.13.png" alt="截屏2021-01-11 下午8.23.13"></p>
<p>先写出B所看到的路由表</p>
<table>
<thead>
<tr>
<th align="left">目的</th>
<th>距离</th>
<th>下一跳</th>
</tr>
</thead>
<tbody><tr>
<td align="left">N2</td>
<td>5</td>
<td>C</td>
</tr>
<tr>
<td align="left">N3</td>
<td>9</td>
<td>C</td>
</tr>
<tr>
<td align="left">N6</td>
<td>5</td>
<td>C</td>
</tr>
<tr>
<td align="left">N8</td>
<td>4</td>
<td>C</td>
</tr>
<tr>
<td align="left">N9</td>
<td>6</td>
<td>C</td>
</tr>
</tbody></table>
<p>更新路由表</p>
<table>
<thead>
<tr>
<th>目的</th>
<th>距离</th>
<th>下一跳</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>N1</td>
<td>7</td>
<td>A</td>
<td>新的路由信息中没有，所以不变</td>
</tr>
<tr>
<td>N2</td>
<td>5</td>
<td>C</td>
<td>新的路由表和原始的路由表都中有，且下一跳相同，以新的为准</td>
</tr>
<tr>
<td>N3</td>
<td>9</td>
<td>C</td>
<td>原始的路由表中没有，插入新的信息</td>
</tr>
<tr>
<td>N6</td>
<td>5</td>
<td>C</td>
<td>新的路由表和原始的路由表都中有，但是下一跳不相同，所以选距离短的，更新</td>
</tr>
<tr>
<td>N8</td>
<td>4</td>
<td>E</td>
<td>新的路由表和原始的路由表都中有，距离相同，不变</td>
</tr>
<tr>
<td>N9</td>
<td>4</td>
<td>F</td>
<td>新的路由表和原始的路由表都中有，但是下一跳不相同，所以选距离短的，不变</td>
</tr>
</tbody></table>
<h3 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h3><p>最大聚合实际上就是把不同的地址聚合到一个大的地址里面去，找地址的最大公共项，并将其个数作为子网掩码1的个数</p>
<h4 id="题目：划分子网"><a href="#题目：划分子网" class="headerlink" title="题目：划分子网"></a>题目：划分子网</h4><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%89%AB%E6%8F%8F%E5%85%A8%E8%83%BD%E7%8E%8B%202021-01-01%2023.50.57_3.jpg" alt="扫描全能王 2021-01-01 23.50.57_3"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/image-20210111174854383.png" alt="image-20210111174854383"></p>
<h3 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><h4 id="题目：试简述RIP，OSPF和BGP路由选择协议的主要特点"><a href="#题目：试简述RIP，OSPF和BGP路由选择协议的主要特点" class="headerlink" title="题目：试简述RIP，OSPF和BGP路由选择协议的主要特点"></a>题目：试简述RIP，OSPF和BGP路由选择协议的主要特点</h4><table>
<thead>
<tr>
<th>主要特点</th>
<th>RIP</th>
<th>OSPF</th>
<th>BGP</th>
</tr>
</thead>
<tbody><tr>
<td>网关协议</td>
<td>内部</td>
<td>内部</td>
<td>外部</td>
</tr>
<tr>
<td>路由表内容</td>
<td>目的网，下一站，距离</td>
<td>目的网，下一站，距离</td>
<td>目的网，完整</td>
</tr>
<tr>
<td>最优通路依据</td>
<td>跳数</td>
<td>费用</td>
<td>多种策略</td>
</tr>
<tr>
<td>算法</td>
<td>距离向量</td>
<td>链路状态</td>
<td>距离矢量</td>
</tr>
<tr>
<td>传送方式</td>
<td>运输层UDP</td>
<td>IP数据报</td>
<td>建立TCP连接</td>
</tr>
<tr>
<td>其他</td>
<td>简单、效率低、跳数为16不可达、好消息传的快，坏消息传的慢</td>
<td>效率高、路由器频繁交换信息，难维持一致性</td>
<td>规模大、统一度量为可达性</td>
</tr>
<tr>
<td>要点</td>
<td>仅和相邻路由器交换信息。   交换的信息是当前本路由器所知道的全部信息，即自己的路由表。   按固定的时间间隔交换路由信息y，例如，每隔 30 秒。</td>
<td>向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。  发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。  “链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。   只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</td>
<td>BGP 协议交换路由信息的结点数量级是自治系统数的量级，这要比这些自治系统中的网络数少很多。  每一个自治系统中 BGP  发言人（或边界路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。  BGP 支持 CIDR，因此 BGP  的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。  在BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。</td>
</tr>
</tbody></table>
<h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>长度为：128位</p>
<p><strong>零压缩</strong>：把多个0写成：：的形式</p>
<h4 id="题目：IPv4向IPv6过渡的方法"><a href="#题目：IPv4向IPv6过渡的方法" class="headerlink" title="题目：IPv4向IPv6过渡的方法"></a>题目：IPv4向IPv6过渡的方法</h4><ul>
<li><p>使用双协议栈</p>
<p>主机或路由器同时装有IPV4和IPV6两个协议栈，因此主机既能和IPV4通 信， 也能和IPV6通信。</p>
</li>
<li><p>使用隧道技术</p>
<p>在IPV6分组进入IPV4网络时，将IPV6分组封装成IPV4分组; 当 封装成IPV4分组 离开IPV4网络时，再装数据部分（IPV6部分）转发给目的节点。</p>
</li>
</ul>
<h2 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章 运输层"></a>第五章 运输层</h2><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><h4 id="题目：端口的作用是什么？为什么端口要划分为三种？"><a href="#题目：端口的作用是什么？为什么端口要划分为三种？" class="headerlink" title="题目：端口的作用是什么？为什么端口要划分为三种？"></a>题目：端口的作用是什么？为什么端口要划分为三种？</h4><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-11%20%E4%B8%8B%E5%8D%888.47.19.png" alt="截屏2021-01-11 下午8.47.19"></p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP首部是8个字节，不保证可靠连接，在传输数据的时候是一次性传输</p>
<h4 id="题目：试用画图解释运输层的复用。画图说明许多个运输用户复用到一条运输连接上，而这条运输连接有复用到IP数据报上。"><a href="#题目：试用画图解释运输层的复用。画图说明许多个运输用户复用到一条运输连接上，而这条运输连接有复用到IP数据报上。" class="headerlink" title="题目：试用画图解释运输层的复用。画图说明许多个运输用户复用到一条运输连接上，而这条运输连接有复用到IP数据报上。"></a>题目：试用画图解释运输层的复用。画图说明许多个运输用户复用到一条运输连接上，而这条运输连接有复用到IP数据报上。</h4><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/image-20210111204405236.png" alt="image-20210111204405236"></p>
<p>UDP头部的格式（在复习指北上有，这里就不赘述了）</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP首部是20个字节，面向流，保证可靠传输，可以实现分组传送</p>
<p><strong>最大报文段长度 MSS</strong>：MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”</p>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/image-20210111212302434.png" alt="image-20210111212302434"></p>
<h4 id="题目：用TCP传送512字节的数据。设窗口为100字节，而TCP报文段每次也是传送100字节的数据。再设发送端和接收端的起始序号分别选为100和200，试画出类似于图5-31的工作示意图。从连接建立阶段到连接释放都要画上。"><a href="#题目：用TCP传送512字节的数据。设窗口为100字节，而TCP报文段每次也是传送100字节的数据。再设发送端和接收端的起始序号分别选为100和200，试画出类似于图5-31的工作示意图。从连接建立阶段到连接释放都要画上。" class="headerlink" title="题目：用TCP传送512字节的数据。设窗口为100字节，而TCP报文段每次也是传送100字节的数据。再设发送端和接收端的起始序号分别选为100和200，试画出类似于图5-31的工作示意图。从连接建立阶段到连接释放都要画上。"></a>题目：用TCP传送512字节的数据。设窗口为100字节，而TCP报文段每次也是传送100字节的数据。再设发送端和接收端的起始序号分别选为100和200，试画出类似于图5-31的工作示意图。从连接建立阶段到连接释放都要画上。</h4><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/IMG_E103B40F9A91-1.jpeg" alt="IMG_E103B40F9A91-1"></p>
<h2 id="第六章-应用层"><a href="#第六章-应用层" class="headerlink" title="第六章 应用层"></a>第六章 应用层</h2><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><h4 id="题目：域名系统的主要功能是什么？域名系统中的本地域名服务器、根域名服务器、顶级域名服务器以及权限域名权服务器有何区别？"><a href="#题目：域名系统的主要功能是什么？域名系统中的本地域名服务器、根域名服务器、顶级域名服务器以及权限域名权服务器有何区别？" class="headerlink" title="题目：域名系统的主要功能是什么？域名系统中的本地域名服务器、根域名服务器、顶级域名服务器以及权限域名权服务器有何区别？"></a>题目：域名系统的主要功能是什么？域名系统中的本地域名服务器、根域名服务器、顶级域名服务器以及权限域名权服务器有何区别？</h4><p>域名系统的主要功能：将域名解析为主机能识别的IP地址。</p>
<p>因特网上的域名服务器系统也是按照域名的层次来安排的。每一个域名服务器都只对域名体系中的一部分进行管辖。共有三种不同类型的域名服务器。即本地域名服务器、根域名服务器、授权域名服务器。当一个本地域名服务器不能立即回答某个主机的查询时，该本地域名服务器就以DNS客户的身份向某一个根域名服务器查询。若根域名服务器有被查询主机的信息，就发送DNS回答报文给本地域名服务器，然后本地域名服务器再回答发起查询的主机。但当根域名服务器没有被查询的主机的信息时，它一定知道某个保存有被查询的主机名字映射的授权域名服务器的IP地址。通常根域名服务器用来管辖顶级域。根域名服务器并不直接对顶级域下面所属的所有的域名进行转换，但它一定能够找到下面的所有二级域名的域名服务器。每一个主机都必须在授权域名服务器处注册登记。通常，一个主机的授权域名服务器就是它的主机ISP的一个域名服务器。授权域名服务器总是能够将其管辖的主机名转换为该主机的IP地址。因特网允许各个单位根据本单位的具体情况将本域名划分为若干个域名服务器管辖区。一般就在各管辖区中设置相应的授权域名服务器。</p>
<h4 id="题目：举例说明域名转换的过程。域名服务器中的高速缓存的作用是什么？"><a href="#题目：举例说明域名转换的过程。域名服务器中的高速缓存的作用是什么？" class="headerlink" title="题目：举例说明域名转换的过程。域名服务器中的高速缓存的作用是什么？"></a>题目：举例说明域名转换的过程。域名服务器中的高速缓存的作用是什么？</h4><p>（1）把不方便记忆的IP地址转换为方便记忆的域名地址。</p>
<p>（2）作用：可大大减轻根域名服务器的负荷，使因特网上的 DNS 查询请求和回答报文的数量大为减少。</p>
<h4 id="题目：试简述SMTP通信的三个阶段的过程。"><a href="#题目：试简述SMTP通信的三个阶段的过程。" class="headerlink" title="题目：试简述SMTP通信的三个阶段的过程。"></a>题目：试简述SMTP通信的三个阶段的过程。</h4><ol>
<li>连接建立：连接是在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。 </li>
<li>邮件传送。</li>
<li>连接释放：邮件发送完毕后，SMTP 应释放 TCP 连接。</li>
</ol>
<h4 id="题目：MIME与SMTP的关系是什么的？什么是quoted-printable编码和base64编码？"><a href="#题目：MIME与SMTP的关系是什么的？什么是quoted-printable编码和base64编码？" class="headerlink" title="题目：MIME与SMTP的关系是什么的？什么是quoted-printable编码和base64编码？"></a>题目：MIME与SMTP的关系是什么的？什么是quoted-printable编码和base64编码？</h4><p>​    MIME全称是通用因特网邮件扩充MIME。它并没有改动或取代SMTP。MIME的意图是继续使用目前的RFC 822格式，但增加了邮件主体的结构，并定义了传送非ASCII码的编码规则。也就是说，MIME邮件可以在现有的电子邮件程序和协议下传送。<br>​    quoted-printable编码：对于所有可打印的ASCII码，除特殊字符等号外，都不改变。等号和不可打印的ASCII码以及非ASCII码的数据的编码方法是：先将每个字节的二进制代码用两个十六进制数字表示，然后在前面再加上一个等号<br>​    base64编码是先把二进制代码划分为一个24位长的单元，然后把每个24位单元划分为4个6位组。每一个6位组按以下方法替换成ASCII码。6位的二进制代码共有64种不同的值，从1到63。用A表示0，用B表示1，等等。26个大写字母排列完毕后，接下去再排26个小写字母，再后面是10个数字，最后用+表示62，而用/表示63。再用两个连在一起的等号==和一个等号=分别表示最后一组的代码只有8位或16位。回车和换行都忽略，它们可在任何地方插入。</p>
<p>base64：将二进制数据拆分为多个6位的二进制，然后在前面补上2个0，再对照ascill码表进行对照</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/image-20210111213505215.png" alt="image-20210111213505215"></p>
<p>quoted-printable：下图</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-12%20%E4%B8%8A%E5%8D%8811.06.50.png" alt="截屏2021-01-12 上午11.06.50"></p>
<h3 id="各个协议所在的层次"><a href="#各个协议所在的层次" class="headerlink" title="各个协议所在的层次"></a>各个协议所在的层次</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%89%AB%E6%8F%8F%E5%85%A8%E8%83%BD%E7%8E%8B%202021-01-01%2023.50.57_4.jpg" alt="扫描全能王 2021-01-01 23.50.57_4"></p>
<h2 id="第七章-网路安全"><a href="#第七章-网路安全" class="headerlink" title="第七章 网路安全"></a>第七章 网路安全</h2><p>见指北</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.zkwzkw.top/2021/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%8C%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kaiwen zhou">
      <meta itemprop="description" content="the web page to share my code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meredith's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%8C%97/" class="post-title-link" itemprop="url">计算机网络复习指北</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-11 22:53:28" itemprop="dateCreated datePublished" datetime="2021-01-11T22:53:28+08:00">2021-01-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="数据交换的方式"><a href="#数据交换的方式" class="headerlink" title="数据交换的方式"></a>数据交换的方式</h3><ul>
<li>电路交换</li>
<li>报文交换</li>
<li>分组交换</li>
</ul>
<h3 id="网络的分类"><a href="#网络的分类" class="headerlink" title="网络的分类"></a>网络的分类</h3><ul>
<li>广域网 WAN</li>
<li>城域网 MAN</li>
<li>局域网 LAN</li>
<li>个人区域网 PAN</li>
</ul>
<h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><ul>
<li><p>速率</p>
<p>  数据的传送速率</p>
</li>
<li><p>带宽</p>
<p>  在信道中所能通过的最高速率</p>
</li>
<li><p>吞吐量</p>
<p>  单位时间内通过某个网络的实际的数据量</p>
</li>
<li><p>时延</p>
<ul>
<li><p>发送时延</p>
<p>  主机或者路由器发送数据帧所需要的时间</p>
</li>
<li><p>传播时延</p>
<p>  电磁波在信道中传播一定的距离需要花费的时间</p>
</li>
<li><p>处理时延</p>
<p>  主机或路由器在收到分组时要花一定的时间进行处理</p>
</li>
<li><p>排队时延</p>
<p>  分组在进入路由器之后要在队列中排队，等待处理</p>
</li>
</ul>
</li>
<li><p>时延带宽积</p>
<p>  时延带宽积传播时延 * 带宽</p>
</li>
<li><p>往返时延 RTT</p>
<p>  双向交互一次所需要的时间</p>
</li>
<li><p>利用率</p>
<p>  并不是越高越好，信道或网络的利用率过高会产生非常大的时延</p>
</li>
</ul>
<h3 id="五层协议的体系结构（从上到下）"><a href="#五层协议的体系结构（从上到下）" class="headerlink" title="五层协议的体系结构（从上到下）"></a>五层协议的体系结构（从上到下）</h3><ul>
<li><p>应用层</p>
<p>  应用层通过应用进程间的交互来完成特定网络应用</p>
<p>  HTTP，FTP……</p>
</li>
<li><p>传输层</p>
<p>  运输层负责向两台主机中进程之间的通信提供通用的数据传输服务</p>
<p>  TCP，UDP</p>
</li>
<li><p>网络层</p>
<p>  网络层负责为分组交换网上的不同主机提供通信服务</p>
<p>  IP</p>
</li>
<li><p>数据链路层</p>
<p>  两台主机之间传送数据是在一段链路上完成的，将上层的ip数据报分装成帧</p>
</li>
<li><p>物理层</p>
<p>  物理层上所传输的数据的单位是比特</p>
</li>
</ul>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%89%AB%E6%8F%8F%E5%85%A8%E8%83%BD%E7%8E%8B%202021-01-01%2023.50.57_2.jpg" alt="扫描全能王 2021-01-01 23.50.57_2"></p>
<h2 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h2><h3 id="源系统的组成"><a href="#源系统的组成" class="headerlink" title="源系统的组成"></a>源系统的组成</h3><ul>
<li><p>源点</p>
<p>  源点设备产生要传输的数据</p>
</li>
<li><p>发送器</p>
<p>  源点生成的数字比特流要通过发送器编码才能在传输系统进行传输（调制解调器）</p>
</li>
<li><p>接收器</p>
<p>  接收传输系统所传送过来的信号</p>
</li>
<li><p>终点</p>
<p>  终点设备从接收器获取传送来的数字比特流，然后把信息输出</p>
</li>
</ul>
<h3 id="信号的分类"><a href="#信号的分类" class="headerlink" title="信号的分类"></a>信号的分类</h3><ul>
<li>模拟信号（连续信号）</li>
<li>数字信号（离散信号）</li>
</ul>
<h3 id="通行方式"><a href="#通行方式" class="headerlink" title="通行方式"></a>通行方式</h3><ul>
<li>单向通信（单工通信）</li>
<li>双向交替通信（半双工通信）</li>
<li>双向同时通信（全双工通信）</li>
</ul>
<h3 id="常用的编码方式"><a href="#常用的编码方式" class="headerlink" title="常用的编码方式"></a>常用的编码方式</h3><ul>
<li>不归零制</li>
<li>归零制</li>
<li>曼切斯特编码</li>
<li>查分曼切斯特编码</li>
</ul>
<h3 id="基本的带通调制方法"><a href="#基本的带通调制方法" class="headerlink" title="基本的带通调制方法"></a>基本的带通调制方法</h3><ul>
<li>调幅（AM）</li>
<li>调频（FM）</li>
<li>调相（PM）</li>
</ul>
<h3 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h3><p>$$<br>C = W log_2(1+S/N)<br>$$</p>
<p>C 表示信道的极限信息传输速率</p>
<p>W 表示信道的带宽</p>
<p>S 表示信道的内所传送信号的平均功率</p>
<p>N 表示信道内部的高斯噪声功率</p>
<h3 id="传输媒介"><a href="#传输媒介" class="headerlink" title="传输媒介"></a>传输媒介</h3><ul>
<li>双绞线</li>
<li>同轴电缆</li>
<li>光缆</li>
</ul>
<h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><ul>
<li><p>频分复用</p>
<p>  所有的用户在相同的时间占用不同的带宽资源</p>
</li>
<li><p>时分复用</p>
<p>  所有的用户在不同的时间占用相同的频带宽度</p>
</li>
<li><p>统计时分复用</p>
<p>  统计时分复用是一种改进的时分复用技术</p>
</li>
<li><p>波分复用</p>
<p>  光的频分复用</p>
</li>
<li><p>码分复用（码分多址 CDMA）</p>
<p>  各用户使用进过特殊挑选的不同码型，因此各个用户之间不会造成干扰</p>
<p>  同时它还有很强的抗干扰能力，不易被敌人发现</p>
</li>
</ul>
<p>频分复用适合模拟通信，利用富余的频率带宽实现多路频率信号的传递； </p>
<p>时分复用适合数字通信，利用富余的时间实现时间片轮转实现多路信号传递；</p>
<p>波分复用和频分复用相似，但适合于光信号传播； </p>
<p>码分复用适合于无线通信。</p>
<h3 id="ADSL技术"><a href="#ADSL技术" class="headerlink" title="ADSL技术"></a>ADSL技术</h3><p>非对称数字用户线（ADSL）技术是数字技术对现有的模拟电话用户进行改造</p>
<p>其将低频谱留给传统的电话，将原来没有利用的高频谱段给上网用户</p>
<p>其下行速度远大于上行速度</p>
<h2 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h2><h3 id="信道的类型"><a href="#信道的类型" class="headerlink" title="信道的类型"></a>信道的类型</h3><ul>
<li>点对点信道</li>
<li>广播信道</li>
</ul>
<h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>在数据的前后添加首部和尾部</p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>通过<strong>字节填充</strong>或<strong>字符填充转义字符</strong></p>
<h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>通过CRC循环冗余码来判断收到的帧有没有差错</p>
<p>会出现下面这三种情况：</p>
<ul>
<li>帧丢失</li>
<li>帧重复</li>
<li>帧失序</li>
</ul>
<h3 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h3><p>PPP是数据链路层的一个协议，通常用来使用户连接ISP</p>
<p>在异步传输时采用字节填充来实现透明传输，规则如下：</p>
<ul>
<li>0x7E ==》0x7D，0x7E</li>
<li>0x7D==》0x7D，0x5D</li>
<li>数值小于0x20==》0x7D，原数字</li>
</ul>
<p>在使用SONET/SDH链路时使用零比特填充实现透明传输，规则如下：</p>
<ul>
<li>连续有5个1之后，立即填充一个0</li>
</ul>
<p>接收方的响应类型：</p>
<ul>
<li><p>配置确认帧</p>
<p>  所有选项都能接受</p>
</li>
<li><p>配置否认帧</p>
<p>  所有选项都能理解但不能接受</p>
</li>
<li><p>配置拒绝帧</p>
<p>  选项有的无法识别或不能接受，需要协商</p>
</li>
</ul>
<h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><p>应用层次：</p>
<p><strong>物理层</strong></p>
<p>作用：</p>
<p>简单的讲所有的设备连接到一个总线上去</p>
<p>特点：</p>
<ul>
<li>带宽 = 总带宽/设备数量</li>
<li>仅仅只是简单的转发比特</li>
<li>各个设备之间互相干扰</li>
<li>结构简单</li>
</ul>
<h3 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a>CSMA/CD协议</h3><p>中文名：</p>
<p>载波监听多点接入/碰撞检测协议</p>
<p>要点：</p>
<ul>
<li><p>多点接入</p>
<p>  计算机以多点接入的方式连接在一根总线上</p>
</li>
<li><p>载波监听</p>
<p>  用来检测信道上有没有其他计算机也在发送</p>
</li>
<li><p>碰撞检测</p>
<p>  边发送边监听</p>
<p>  自己在发送数据时是否有其他的计算机也在发送数据</p>
</li>
</ul>
<p>从协议中可以看出，CSMA/CD所应用的网络是一个半双工的网络</p>
<p>争用期为2t（两倍的传播时延），过了争用期就不会发送碰撞</p>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC地址是物理地址，全球唯一</p>
<p>通过MAC地址可以找到唯一的计算机设备，可以发送一下三种帧：</p>
<ul>
<li>单波帧</li>
<li>广播帧</li>
<li>多波帧</li>
</ul>
<h3 id="以太网交换机"><a href="#以太网交换机" class="headerlink" title="以太网交换机"></a>以太网交换机</h3><p>实际上是一个多接口的网桥</p>
<p>应用层次：</p>
<p>数据链路层</p>
<p>优点：</p>
<ul>
<li>独占传输媒体（带宽），无碰撞地传输数据</li>
<li>拥有自学习能力，交换表自动生成</li>
</ul>
<p>交换表生成</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="网络层的作用"><a href="#网络层的作用" class="headerlink" title="网络层的作用"></a>网络层的作用</h3><p>向上提供简单灵活的，无连接的，进最大努力交付的数据报服务</p>
<p>网络层将不同的异构网络统一</p>
<h3 id="网络互联要使用到的中间设备"><a href="#网络互联要使用到的中间设备" class="headerlink" title="网络互联要使用到的中间设备"></a>网络互联要使用到的中间设备</h3><ul>
<li>物理层使用的中间设备叫做转发器</li>
<li>数据链路层使用的中间设备叫做网桥或桥接器</li>
<li>网络层使用的中间设备叫做路由器</li>
<li>网络层以上使用的中间设备叫做网关</li>
</ul>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址在整个互联网范围内都是唯一的</p>
<p>IP地址 = 网络号+主机号</p>
<table>
<thead>
<tr>
<th>网络名</th>
<th>网络号</th>
<th>子网掩码</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>A类地址</td>
<td>1～126</td>
<td>255.0.0.0</td>
<td></td>
</tr>
<tr>
<td>B类地址</td>
<td>128.0～191.255</td>
<td>255.255.0.0</td>
<td></td>
</tr>
<tr>
<td>C类地址</td>
<td>192.0.0～223.255.255</td>
<td>255.255.255.0</td>
<td></td>
</tr>
<tr>
<td></td>
<td>127</td>
<td>255.0.0.0</td>
<td>用于本地软件回环测试</td>
</tr>
</tbody></table>
<h3 id="IP地址与MAC地址的区别"><a href="#IP地址与MAC地址的区别" class="headerlink" title="IP地址与MAC地址的区别"></a>IP地址与MAC地址的区别</h3><p>MAC地址是工作在物理层和数据链路层</p>
<p>而IP地址是工作在网络层及其之上的层次，且IP地址是一个逻辑地址</p>
<p>在IP层抽象的互联网上只能看到IP数据报</p>
<p>在局域网的链路层只能看见MAC帧</p>
<p>IP层抽象的互联网屏蔽了下层复杂的细节，使用统一的，抽象的IP地址研究主机和主机或者路由器之间的通信</p>
<h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3><p>作用：</p>
<p>在同一个局域网上主机或者路由器IP地址与MAC地址之间的映射问题</p>
<p>过程：</p>
<ul>
<li>ARP进程在本局域网中广播一个ARP请求分组，分组中有发送方的IP和MAC地址</li>
<li>本局域网上的所有主机运行的ARP进程都收到次ARP请求分组</li>
<li>目的主机在收到这个ARP请求之后将请求中的IP与MAC记录下来，然后发送一个ARP响应分组</li>
<li>请求方在接收到响应之后记录下IP与MAC地址，之后的通行就可以通过IP直接来完成</li>
</ul>
<h3 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/0B2452EE-BCC2-4A68-9D22-D7930D56EE6F.jpg" alt="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/0B2452EE-BCC2-4A68-9D22-D7930D56EE6F.jpg"></p>
<ul>
<li><p>版本</p>
<p>  表示的是IP协议的版本</p>
</li>
<li><p>首部长度</p>
<p>  表示首部的长度</p>
</li>
<li><p>区分服务</p>
<p>  用来表示服务类型，一般不用</p>
</li>
<li><p>总长度</p>
<p>  指首部+数据的总长度，以太网规定最大传送单元（MTU）为固定的1500字节</p>
</li>
<li><p>标识</p>
<p>  每产生一个数据报，次标识就会加1，但这个表示不是序号，使用来将分片之后的数据报重新组合</p>
</li>
<li><p>标志</p>
<p>  占3位，但是只有两位才有意义</p>
<ul>
<li><p>最低位MF</p>
<p>  MF = 1表示后面还有分片</p>
</li>
<li><p>中间位DF</p>
<p>  只有DF = 0才允许分片</p>
</li>
</ul>
</li>
<li><p>片偏移</p>
<p>  用来组合分片之后各个片之间数据部分</p>
<p>  片偏移 = 数据在整个IP数据报中数据中的的首地址 / 8</p>
</li>
<li><p>生存时间（TTL）</p>
<p>  每经过一个路由器就会减去在这个路由器上所花的时间，直到TTL = 0，路由器会丢掉这个数据包</p>
</li>
<li><p>协议</p>
<p>  让上层知道接下来用哪个协议来处理这个数据报</p>
</li>
<li><p>首部校验和</p>
<p>  只能检验数据报的首部，不包括数据部分</p>
</li>
<li><p>源地址</p>
</li>
<li><p>目的地址</p>
</li>
</ul>
<h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>字段：</p>
<ul>
<li><p>目的地址网络</p>
<p>  存放的是网络号</p>
</li>
<li><p>下一跳地址</p>
<p>  存放的是接口的地址</p>
</li>
</ul>
<h3 id="路由器中的分组转发算法"><a href="#路由器中的分组转发算法" class="headerlink" title="路由器中的分组转发算法"></a>路由器中的分组转发算法</h3><ul>
<li>从数据报的首部提取出目的主机的IP地址，通过与子网掩码相与得到网络号</li>
<li>如果该网络号就是与该路由器相连的某个网络地址，那么就直接交付（这里包括将IP地址转换成MAC地址），否则进行间接交付下一步</li>
<li>如果路由表中有目的地址为该IP的特定主机路由，那么就将数据报发送给指明下一跳的路由器，否则进行下一步</li>
<li>如果路由表中存在由到达该网络的路由，那么就将数据报传送到期所指明的下一跳路由，否则进行下一步</li>
<li>如果路由表中有默认路由，那么就把数据报传送给默认路由指明的下一跳路由，否则下一步</li>
<li>报告转发分组出错</li>
</ul>
<h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><p>结构：</p>
<p>IP地址 = 网络号+子网号+主机号</p>
<p>IP地址通过与子网掩码相与得到网络号</p>
<h3 id="无分类编址-CIDR"><a href="#无分类编址-CIDR" class="headerlink" title="无分类编址 CIDR"></a>无分类编址 CIDR</h3><p>结构：</p>
<p>IP地址 = 网络前缀+主机号</p>
<p>128.14.35.7/20<br>前面表示IP地址，后面表示前面20是网络号</p>
<p>特点：</p>
<p>消除了传统的ABC类地址以及划分子网的概念</p>
<h3 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h3><p>ping命令使用的协议</p>
<h2 id="第五章-运输层"><a href="#第五章-运输层" class="headerlink" title="第五章 运输层"></a>第五章 运输层</h2><h3 id="运输层的作用"><a href="#运输层的作用" class="headerlink" title="运输层的作用"></a>运输层的作用</h3><p>运输层提供应用进程间的逻辑通信</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>特点：</p>
<ul>
<li><p>无连接</p>
<p>  发送数据之前无需事先建立连接</p>
</li>
<li><p>尽最大努力交付</p>
<p>  不保证可靠交付</p>
</li>
<li><p>面向报文</p>
<p>  在发送时保留报文的边界，一次性全部发出</p>
</li>
<li><p>没有拥塞控制</p>
</li>
<li><p>支持一对一，一对多，多对多的交互通信</p>
</li>
<li><p>首部开销小</p>
</li>
</ul>
<p>首部格式：</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/F03AE319-6F78-429C-BFC7-5FA2B5B762E7.jpeg" alt="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/F03AE319-6F78-429C-BFC7-5FA2B5B762E7.jpeg"></p>
<p>源端口：需要对方回信时使用，不需要全0</p>
<p>目的端口：在终点交付报文时使用</p>
<p>长度：UDP用户数据报的长度，最短为8字节（仅首部）</p>
<p>校验和：检测UDP用户数据报在传输中是否有差错，有差错就丢弃</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p><strong>特点：</strong></p>
<ul>
<li>面向连接</li>
<li>提供可靠交付</li>
<li>提供全双工通信</li>
<li>面向字节流</li>
</ul>
<p><strong>可靠传输的工作原理：</strong></p>
<ul>
<li><p>停止等待协议</p>
<p>  在发送一个报文之后，会等待接收方回复</p>
</li>
<li><p>连续ARQ协议</p>
<p>  维持一个发送窗口，连续将多个分组发送，不需要对方一个一个确认，而是收到分组之后，之前的分组默认也收到了</p>
</li>
</ul>
<p><strong>首部格式：</strong></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/9655D3A7-F96A-4801-BC93-AA3EA51B8620.jpeg" alt="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/9655D3A7-F96A-4801-BC93-AA3EA51B8620.jpeg"></p>
<ul>
<li>源端口和目的端口</li>
<li>序号：每个字节都是按顺序编号，保证数据是有序的</li>
<li>确认号：期望收到对方下一个报文段的第一个数据字节的序号</li>
<li>数据偏移：表示TCP报文段首部的长度</li>
<li>保留</li>
<li>紧急URG：URG = 1表示有效，发送方TCP会把紧急数据插入到本报文段数据的最前面，要与首部中的紧急指针配合使用</li>
<li>确认ACK：ACK = 1表示有效，在建立连接之后ACK都必须为1</li>
<li>推送PSH：不需要等待缓存满了再发送，直接发送</li>
<li>复位RST：RST = 表示有效，表示连接出现了严重的错误，要重新连接</li>
<li>同步SYN：SYN = 1 and ACK = 0 表示这是一个请求连接的报文，若对方同意连接就会返回一个SYN = 1 and ACK = 1的报文，这里的SYN就是表示请求连接或连接接受报文</li>
<li>终止FIN：FIN = 1表示终止，释放连接</li>
<li>窗口：告诉对方现在的窗口大小</li>
<li>校验和：检验首部和数据</li>
<li>紧急执政：当URG = 1才有意义，指出报文中紧急数据的位置</li>
<li>选项：长度可变</li>
</ul>
<p><strong>TCP实现可靠传输：</strong></p>
<ul>
<li>以字节为单位的滑动窗口</li>
<li>超时重传时间选择</li>
<li>选择确认SACK</li>
</ul>
<p><strong>流量控制：</strong></p>
<p>让发送方的发送速率不要太快，让接收方来得及接受</p>
<p>双方都维持一个窗口，发送方的窗口不能大于接收方的</p>
<p>若接收方的窗口一直为0，发送方就启动一个持续计时器，当时间到了之后放一个1字节的探测报文段</p>
<p><strong>用塞控制：</strong></p>
<p>防止过多的数据注入到网络中</p>
<p>拥塞控制的方法：</p>
<ul>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="应用层的作用"><a href="#应用层的作用" class="headerlink" title="应用层的作用"></a>应用层的作用</h3><p>解决位于不同主机中多个应用进程之间的通信和协同工作的问题</p>
<h3 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><p>底层使用的是UDP</p>
<p>将域名转换为IP地址</p>
<h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><ul>
<li>根域名服务器</li>
<li>顶级域名服务器（TLD）</li>
<li>权限域名服务器</li>
<li>本地域名服务器</li>
</ul>
<p>主机向本地域名服务器的查询一般采用<strong>递归查询</strong></p>
<p>本地域名服务器向根域名服务器的查询一般采用<strong>迭代查询</strong></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-09%20%E4%B8%8A%E5%8D%8811.16.12.png" alt="截屏2021-01-09 上午11.16.12"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-09%20%E4%B8%8A%E5%8D%8811.16.17.png" alt="截屏2021-01-09 上午11.16.17"></p>
<h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>基于TCP</p>
<h3 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h3><p>基于UDP</p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>统一资源定位符</p>
<p>格式：**&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;**</p>
<h3 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h3><p>SMTP 简单邮件传送协议，用来<strong>发送邮件</strong>，但是不能发送附件和</p>
<p>MINE 是SMTP的扩展，可以用来发送附件</p>
<p>POP3 是用来接收邮件</p>
<h3 id="base-编码"><a href="#base-编码" class="headerlink" title="base 编码"></a>base 编码</h3><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>分配IP的协议</p>
<h3 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h3><p>简单网络管理协议</p>
<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="计算机网络都面临哪几种威胁？主动攻击和被动攻击的区别是什么？对于计算机网络的安全措施都有哪些？"><a href="#计算机网络都面临哪几种威胁？主动攻击和被动攻击的区别是什么？对于计算机网络的安全措施都有哪些？" class="headerlink" title="计算机网络都面临哪几种威胁？主动攻击和被动攻击的区别是什么？对于计算机网络的安全措施都有哪些？"></a>计算机网络都面临哪几种威胁？主动攻击和被动攻击的区别是什么？对于计算机网络的安全措施都有哪些？</h3><ul>
<li>被动攻击<ul>
<li>指攻击者从网络上窃听他人的通信内容</li>
</ul>
</li>
<li>主动攻击<ul>
<li>篡改</li>
<li>恶意程序<ul>
<li>计算机病毒</li>
<li>网络蠕虫</li>
<li>特洛伊木马</li>
<li>逻辑炸弹</li>
<li>后门入侵</li>
<li>流氓软件</li>
</ul>
</li>
<li>拒绝服务（Dos）</li>
</ul>
</li>
</ul>
<p>计算机网络面临以下的四种威胁：截获（interception），中断(interruption)，篡改(modification），伪造(fabrication）。 </p>
<p>  网络安全的威胁可以分为两大类：即被动攻击和主动攻击。 </p>
<p>  主动攻击是指攻击者对某个连接中通过的PDU进行各种处理。如有选择地更改、删除、延迟这些PDU。甚至还可将合成的或伪造的PDU送入到一个连接中去。主动攻击又可进一步划分为三种，即更改报文流；拒绝报文服务；伪造连接初始化。 </p>
<p>  被动攻击是指观察和分析某一个协议数据单元PDU而不干扰信息流。即使这些数据对攻击者来说是不易理解的，它也可通过观察PDU的协议控制信息部分，了解正在通信的协议实体的地址和身份，研究PDU的长度和传输的频度，以便了解所交换的数据的性质。这种被动攻击又称为通信录分析。 </p>
<p>  还有一种特殊的主动攻击就是恶意程序的攻击。恶意程序种类繁多，对网络安全威胁较大的主要有以下几种：计算机病毒；计算机蠕虫；特洛伊木马；逻辑炸弹。 </p>
<p>  对付被动攻击可采用各种数据加密动技术，而对付主动攻击，则需加密技术与适当的鉴别技术结合。</p>
<h3 id="为什么需要进行报文鉴别？鉴别和保密、授权有什么不同？报文鉴别和实体鉴别有什么区别？"><a href="#为什么需要进行报文鉴别？鉴别和保密、授权有什么不同？报文鉴别和实体鉴别有什么区别？" class="headerlink" title="为什么需要进行报文鉴别？鉴别和保密、授权有什么不同？报文鉴别和实体鉴别有什么区别？"></a>为什么需要进行报文鉴别？鉴别和保密、授权有什么不同？报文鉴别和实体鉴别有什么区别？</h3><ul>
<li>使用报文鉴别是为了对付主动攻击中的篡改和伪造。当报文加密的时候就可以达到报文鉴别的目的，但是当传送不需要加密报文时，接收者应该能用简单的方法来鉴别报文的真伪。 </li>
<li>鉴别和保密并不相同。鉴别是要验证通信对方的确是自己所需<br>通信的对象，而不是其他的冒充者。鉴别分为报文鉴别和实体鉴别。授权涉及到的问题是：所进行的过程是否被允许(如是否可以对某文件进行读或写)。 </li>
<li>报文鉴别和实体鉴别不同。报文鉴别是对每一个收到的报文都要鉴别报文的发送者，而实体鉴别是在系统接入的全部持续时间内对和自己通信的对方实体只需验证一次。</li>
</ul>
<h3 id="什么是“中间人攻击”？怎样防止这种攻击？"><a href="#什么是“中间人攻击”？怎样防止这种攻击？" class="headerlink" title="什么是“中间人攻击”？怎样防止这种攻击？"></a>什么是“中间人攻击”？怎样防止这种攻击？</h3><ul>
<li>中间人攻击（Man-in -the-Middle Attack ，简称“MIT M 攻击”）是一种“间接”的入侵攻击这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。然后入侵者把这台计算机模拟一台或两台原始计算机，使“中间人”能够与原始计算机建立活动连接并允许其读取或篡改传递的信息，然而两个原始计算机用户却认为他们是在互相通信，因而这种攻击方式并不很容易被发现。所以中间人攻击很早就成为了黑客常用的一种古老的攻击手段，并且一直到今天还具有极大的扩展空间。 </li>
<li>要防范MIT M 攻击，我们可以将一些机密信息进行加密后再传输， 这样即使被“中间人”截取也难以破解，另外，有一些认证方式可以检测到MIT M 攻击。比如设备或IP 异常检测：如果用户以前从未使用某个设备或IP 访问系统，则系统会采取 措施。还有设备或IP 频率检测：如果单一的设备或IP 同时访问大量的用户帐号， 系统也会采取措施。更有效防范MIT M 攻击的方法是进行带外认证。 </li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.zkwzkw.top/2021/01/08/%E7%AE%97%E6%B3%95ppt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kaiwen zhou">
      <meta itemprop="description" content="the web page to share my code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meredith's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/08/%E7%AE%97%E6%B3%95ppt/" class="post-title-link" itemprop="url">算法ppt总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-08 10:01:52" itemprop="dateCreated datePublished" datetime="2021-01-08T10:01:52+08:00">2021-01-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ppt"><a href="#ppt" class="headerlink" title="ppt"></a>ppt</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="程序的组成"><a href="#程序的组成" class="headerlink" title="程序的组成"></a>程序的组成</h3><p><strong>程序＝数据结构＋算法</strong></p>
<h3 id="什么是算法？"><a href="#什么是算法？" class="headerlink" title="什么是算法？"></a><strong>什么是算法？</strong></h3><p><strong>算法是解一确定类问题的任意一种特殊的方法</strong></p>
<p><strong>算法是一组有穷的规则，它规定了解决某一特定类型问题的一系列运算。</strong></p>
<h3 id="算法的五个重要特性"><a href="#算法的五个重要特性" class="headerlink" title="算法的五个重要特性"></a>算法的五个重要特性</h3><p><strong>确定性、能行性、输入、输出、有穷性/有限性</strong></p>
<h3 id="为什么要考虑时间复杂性？"><a href="#为什么要考虑时间复杂性？" class="headerlink" title="为什么要考虑时间复杂性？"></a>为什么要考虑时间复杂性？</h3><p><strong>1.有些计算机需要用户提供程序运行时 间的上限，一旦达到这个上限，程序 将被强制结束。</strong></p>
<p><strong>2.正在开发的程序可能需要提供一个满 意的实时响应。</strong></p>
<h3 id="为什么要考虑空间复杂性？"><a href="#为什么要考虑空间复杂性？" class="headerlink" title="为什么要考虑空间复杂性？"></a>为什么要考虑空间复杂性？</h3><p><strong>1.多用户系统中运行时，需指明分配给该程序的内存大小。</strong></p>
<p><strong>2.可提前知道是否有足够可用的内存来运行该程序。</strong></p>
<p><strong>3.一个问题可能有若干个内存需求各不相同的解决方案，从中择取。</strong></p>
<p><strong>4.利用空间复杂性来估算一个程序所能解决问题的最大规模。</strong></p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%889.45.04.png" alt="截屏2021-01-07 下午9.45.04"></p>
<h3 id="提高算法质量的原则"><a href="#提高算法质量的原则" class="headerlink" title="提高算法质量的原则"></a>提高算法质量的原则</h3><ul>
<li>保证正确性、可靠性、健壮性、可读性</li>
<li>提高效率</li>
</ul>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>无</p>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="蛮力法"><a href="#蛮力法" class="headerlink" title="蛮力法"></a>蛮力法</h3><p><strong>根据问题中条件将可能情况一一列举出来，逐一尝试从中找出满足问题条件的解。但有时一一列举出的情况数目很大，则需要进一步考虑，排除一些明显不合理的情况，尽可能减少问题可能解的列举数目。</strong></p>
<p>  <strong>1）找出枚举范围：分析问题所涉及的各种情况。</strong></p>
<p>  <strong>2）找出约束条件：分析问题的解需要满足的条件，并用逻辑表达式表示。</strong></p>
<h2 id="第四章-贪心算法"><a href="#第四章-贪心算法" class="headerlink" title="第四章 贪心算法"></a>第四章 贪心算法</h2><h3 id="贪婪的思想"><a href="#贪婪的思想" class="headerlink" title="贪婪的思想"></a>贪婪的思想</h3><p>以逐步的局部最优，达到最终的全局最优。</p>
<p>贪婪算法通过一系列的局部选择来得到一个问题的解。所作的每一个选择都是当前状态下“最优”的选择。</p>
<h3 id="贪婪的性质"><a href="#贪婪的性质" class="headerlink" title="贪婪的性质"></a>贪婪的性质</h3><ul>
<li><strong>贪婪选择性质</strong><ul>
<li>指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。</li>
<li>贪心算法通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。</li>
</ul>
</li>
<li><strong>最优子结构性质</strong><ul>
<li>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</li>
</ul>
</li>
</ul>
<h3 id="币种统计问题"><a href="#币种统计问题" class="headerlink" title="币种统计问题"></a>币种统计问题</h3><p>题目：<strong>某单位给每个职工发工资(精确到元)。为了保证不要临时兑换零钱，且取款的张数最少，取工资前要统计出所有职工的工资所需各种币值(100,50,20,10,5,2,1元共七种)的张数。请编程完成</strong></p>
<p>策略：<strong>对每个人的工资，用“贪婪”的思想，先尽量多地取大面额的币种，由大面额到小面额币种逐渐统计。</strong></p>
<p>如果某国的币种是这样的,共9种:100,70,50,20,10,7,5,2,1，则使用贪婪就无法得到最优解，<strong>在这里用贪心算法是有条件的——后一个的权值（这里就是纸币面值）是前一个的2倍或以上才可以使用</strong>，7、70破坏了“取最优”的贪婪策略的正确性，应该使用动态规划来解决</p>
<p>选择的贪心策略必须具备<strong>无后效性</strong>，即<strong>某个状态以前的过程不会影响以后的状态，只与当前状态有关。</strong></p>
<h3 id="为什么0-1背包问题不能用贪心算法得到最优解"><a href="#为什么0-1背包问题不能用贪心算法得到最优解" class="headerlink" title="为什么0-1背包问题不能用贪心算法得到最优解?"></a>为什么0-1背包问题不能用贪心算法得到最优解?</h3><p>对于0-1背包问题，贪心选择之所以不能得到最优解是因为在这种情况下，它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包的价值降低了。</p>
<p>事实上，在考虑0-1背包问题时，应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择。由此就导出许多互相重叠的子问题。</p>
<h2 id="第五章-动态规划"><a href="#第五章-动态规划" class="headerlink" title="第五章 动态规划"></a>第五章 动态规划</h2><h3 id="动态规划的基本思想"><a href="#动态规划的基本思想" class="headerlink" title="动态规划的基本思想"></a>动态规划的基本思想</h3><p>动态规划方法的基本思想是，把求解的问题分成许多阶段或多个子问题，然后按顺序求解各子问题。最后一个子问题就是初始问题的解。</p>
<p>由于动态规划的问题有重叠子问题的特点，为了减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p>
<p><strong>动态规划=贪婪策略+递推(降阶)+存储递推结果</strong></p>
<h3 id="动态规划的性质"><a href="#动态规划的性质" class="headerlink" title="动态规划的性质"></a>动态规划的性质</h3><ul>
<li><strong>最优化原理(或称为最佳原则、最优子结构)</strong></li>
<li><strong>无后向性(无后效性)：某阶段状态一旦确定以后，就不受这个状态以后决策的影响。即某状态以后的过程不会影响以前的状态，只与当前状态有关。</strong></li>
</ul>
<h3 id="动态规划填表坐标"><a href="#动态规划填表坐标" class="headerlink" title="动态规划填表坐标"></a>动态规划填表坐标</h3><p>横坐标一般是可用资源的总数（背包的容量）</p>
<p>纵坐标一般是使用的资源量（物品的重量）</p>
<h3 id="资源分配问题"><a href="#资源分配问题" class="headerlink" title="资源分配问题"></a>资源分配问题</h3><p>横坐标是可用资源的总数</p>
<p>纵坐标是各类资源的分配情况</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%8811.41.27.png" alt="截屏2021-01-07 下午11.41.27"></p>
<h3 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h3><p>使用r[]来表示矩阵的大小</p>
<p>mij表示从Mi乘到Mj</p>
<p>下面分为三种情况：</p>
<ul>
<li>当i = j时, 表示就一个矩阵那么此时就等于0</li>
<li>当i+1 = j时，表示就两个矩阵相乘，结果就是r[i]*r[i+1]*r[i+2]</li>
<li>当i&lt; j时，且i &lt;= k &lt;= j，这里k表示夹在i， j之间，结果为*<em>m(i, k) + m(k+1, j) + ri\</em>r(k+1)*r(j+1)**，需要注意的是由于无法知道k的值，所以这里是一个循环，要找到其中的最小值</li>
</ul>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>从后向前</p>
<p>横坐标是第一个子串的长度，纵坐标是第二个子串的长度</p>
<p>分别有两个情况：</p>
<ul>
<li>当子串中的字符匹配，最大长度就是匹配之前的长度+1（每个子串分别减1的长度），也就是左上角的元素+1</li>
<li>当子串没有发生匹配，那就是max（第一个子串-1， 第二个子串-1），也就是上面一个或者左边的一个</li>
</ul>
<h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>横坐标是背包的大小，纵坐标是物品的重量</p>
<p>主要分为以下两种情况：</p>
<ul>
<li>取物品，就是物品的价值+减去物品重量之后的最大价值（在上面一行）</li>
<li>不取物品，就继承上面的状态（上面的格子）</li>
</ul>
<p>比较两个的大小</p>
<h3 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%8812.13.05.png" alt="截屏2021-01-08 上午12.13.05"></p>
<p>this_sum 是当前子串之和，而sum是最大子串之和</p>
<p>sum主要是纪录this_sum中出现的最大子串的大小</p>
<p>this_sum第一个永远是0，</p>
<ul>
<li>后面的如果之前的是正数或者是0，那么就是之前的结果加上现在的结果</li>
<li>如果之间的结果是负数，则不要之前的结果，只要现在的结果</li>
</ul>
<p>sum第一个永远是0，</p>
<ul>
<li>如果this_sum的值大于之前的sum，那么此时的sum就等于this_sum</li>
<li>反之等于之前的sum</li>
</ul>
<h2 id="第六章-分治法"><a href="#第六章-分治法" class="headerlink" title="第六章 分治法"></a>第六章 分治法</h2><h3 id="分治算法思想"><a href="#分治算法思想" class="headerlink" title="分治算法思想"></a>分治算法思想</h3><p>将整个问题分解成若干个小问题后分而治之。</p>
<h3 id="分治算法的基本步骤"><a href="#分治算法的基本步骤" class="headerlink" title="分治算法的基本步骤"></a>分治算法的基本步骤</h3><p>1)分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；<br>2)解决：若子问题规模较小而容易被解决则直接解，否则再继续分解为更小的子问题，直到容易解决；<br>3)合并：将已求解的各个子问题的解，逐步合并为原问题的解。</p>
<h3 id="分治法的一般框架"><a href="#分治法的一般框架" class="headerlink" title="分治法的一般框架"></a>分治法的一般框架</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	Divide-<span class="keyword">and</span>-Conquer(<span class="keyword">int</span>  n) &#123;                     <span class="comment">//n为问题规模</span></span><br><span class="line">	     <span class="keyword">if</span> (n≤n0) &#123;                           <span class="comment">//n0为可解子问题的规模    	 解子问题；</span></span><br><span class="line">		 <span class="keyword">return</span>(子问题的解)；&#125;</span><br><span class="line">	     <span class="keyword">for</span> (i=<span class="number">1</span> ;i&lt;=k;i++)       <span class="comment">//分解为较小子问题p1,p2,…pk     </span></span><br><span class="line">         yi=Divide-<span class="keyword">and</span>-Conquer(|Pi|);              <span class="comment">//递归解决Pi     </span></span><br><span class="line">    		 T =MERGE(y1,y2,...,yk);                          <span class="comment">//合并子问题             </span></span><br><span class="line">    <span class="keyword">return</span>(T); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>思想：先划分，再归并</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">arr = []</span><br><span class="line"><span class="comment"># 进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sort</span>(<span class="params">left, mid, right</span>):</span></span><br><span class="line">  i = left</span><br><span class="line">  arr1 = arr[left: mid+<span class="number">1</span>]</span><br><span class="line">  arr2 = arr[mid+<span class="number">1</span>: right+<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">while</span> <span class="built_in">len</span>(arr1) &gt; <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(arr2) &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> arr1[<span class="number">0</span>] &gt; arr2[<span class="number">0</span>]:</span><br><span class="line">      arr[i] = arr2[<span class="number">0</span>]</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      <span class="keyword">del</span> arr2[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">      arr[i] = arr1[<span class="number">0</span>]</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      <span class="keyword">del</span> arr1[<span class="number">0</span>]</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">while</span> <span class="built_in">len</span>(arr1) &gt; <span class="number">0</span>:</span><br><span class="line">      arr[i] = arr1[<span class="number">0</span>]</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      <span class="keyword">del</span> arr1[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">while</span> <span class="built_in">len</span>(arr2) &gt; <span class="number">0</span>:</span><br><span class="line">      arr[i] = arr2[<span class="number">0</span>]</span><br><span class="line">      i += <span class="number">1</span></span><br><span class="line">      <span class="keyword">del</span> arr2[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先进行拆分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">break</span>(<span class="params">left, right</span>):</span></span><br><span class="line">  <span class="comment"># 递归退出条件</span></span><br><span class="line">  <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  mid = <span class="built_in">int</span>(left+right)</span><br><span class="line">  <span class="keyword">break</span>(left, mid)</span><br><span class="line">  <span class="keyword">break</span>(mid+<span class="number">1</span>, right)</span><br><span class="line">  sort(left, mid, right)</span><br></pre></td></tr></table></figure>
<h3 id="金块问题"><a href="#金块问题" class="headerlink" title="金块问题"></a>金块问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> a[n]</span><br><span class="line"></span><br><span class="line">maxmin(i, j, <span class="built_in">max</span>, <span class="built_in">min</span>):</span><br><span class="line">  <span class="built_in">min</span> = <span class="built_in">int</span>((i+j)/<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">if</span> i == j:</span><br><span class="line">    <span class="built_in">max</span> = a[i]</span><br><span class="line">    <span class="built_in">min</span> = a[j]</span><br><span class="line">  <span class="keyword">elif</span> i = j-<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> a[i] &gt; a[j]:</span><br><span class="line">      <span class="built_in">max</span> = a[j]</span><br><span class="line">      <span class="built_in">min</span> = a[i]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="built_in">max</span> = a[i]</span><br><span class="line">      <span class="built_in">min</span> = a[j]</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 进行拆分</span></span><br><span class="line">    maxmin(i, mid, <span class="built_in">max</span>)</span><br><span class="line">    maxmin(mid+<span class="number">1</span>, j)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="残缺棋盘"><a href="#残缺棋盘" class="headerlink" title="残缺棋盘"></a>残缺棋盘</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%882.49.19.png" alt="截屏2020-12-19 下午2.49.19"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_chess</span>(<span class="params">棋盘的大小, 棋盘的顶点横坐标, 棋盘的顶点纵坐标, 缺少位置的横坐标, 缺少位置的纵坐标</span>):</span></span><br><span class="line">  <span class="comment"># 递归的出口</span></span><br><span class="line">  <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="comment"># 首先进行棋盘的分割</span></span><br><span class="line">  <span class="comment"># 左上角</span></span><br><span class="line">  <span class="keyword">if</span> 缺失的格子在左上角:</span><br><span class="line">    play_chess(棋盘位置调整到左上角，缩小规模)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    chess_board[中心点的左上方坐标] = trace_step</span><br><span class="line">    play_chess(棋盘位置调整到左上角, 缩小规模, 更新缺少的点)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 右上角</span></span><br><span class="line">  <span class="keyword">if</span> 缺失的格子在右上角:</span><br><span class="line">    play_chess(棋盘位置调整到右上角，缩小规模)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    chess_board[中心点的右上方坐标] = trace_step</span><br><span class="line">    play_chess(棋盘位置调整到右上角, 缩小规模, 更新缺少的点)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 左下角</span></span><br><span class="line">  <span class="keyword">if</span> 缺失的格子在左下角:</span><br><span class="line">    play_chess(棋盘位置调整到左下角，缩小规模)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    chess_board[中心点的左下方坐标] = trace_step</span><br><span class="line">    play_chess(棋盘位置调整到左下角, 缩小规模, 更新缺少的点)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 右下角</span></span><br><span class="line">  <span class="keyword">if</span> 缺失的格子在右下角:</span><br><span class="line">    play_chess(棋盘位置调整到右下角，缩小规模)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    chess_board[中心点的右下方坐标] = trace_step</span><br><span class="line">    play_chess(棋盘位置调整到右下角, 缩小规模, 更新缺少的点)</span><br></pre></td></tr></table></figure>
<h3 id="循环赛日程表"><a href="#循环赛日程表" class="headerlink" title="循环赛日程表"></a>循环赛日程表</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.05.26.png" alt="截屏2021-01-08 上午1.05.26"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.05.57.png" alt="截屏2021-01-08 上午1.05.57"></p>
<h2 id="第七章-图搜索基础"><a href="#第七章-图搜索基础" class="headerlink" title="第七章 图搜索基础"></a>第七章 图搜索基础</h2><h3 id="图的基本术语"><a href="#图的基本术语" class="headerlink" title="图的基本术语"></a>图的基本术语</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.11.22.png" alt="截屏2021-01-08 上午1.11.22"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.11.38.png" alt="截屏2021-01-08 上午1.11.38"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.12.10.png" alt="截屏2021-01-08 上午1.12.10"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.12.24.png" alt="截屏2021-01-08 上午1.12.24"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.12.44.png" alt="截屏2021-01-08 上午1.12.44"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.13.01.png" alt="截屏2021-01-08 上午1.13.01"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.13.11.png" alt="截屏2021-01-08 上午1.13.11"></p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.14.01.png" alt="截屏2021-01-08 上午1.14.01"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.14.15.png" alt="截屏2021-01-08 上午1.14.15"></p>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.14.57.png" alt="截屏2021-01-08 上午1.14.57"></p>
<h3 id="显式图和隐式图"><a href="#显式图和隐式图" class="headerlink" title="显式图和隐式图"></a>显式图和隐式图</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.17.29.png" alt="截屏2021-01-08 上午1.17.29"></p>
<h3 id="子集树，排列树"><a href="#子集树，排列树" class="headerlink" title="子集树，排列树"></a>子集树，排列树</h3><p>两个都是隐式图</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.18.49.png" alt="截屏2021-01-08 上午1.18.49"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.19.00.png" alt="截屏2021-01-08 上午1.19.00"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.18.14.png" alt="截屏2021-01-08 上午1.18.14"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.18.25.png" alt="截屏2021-01-08 上午1.18.25"></p>
<h3 id="图搜索的术语"><a href="#图搜索的术语" class="headerlink" title="图搜索的术语"></a>图搜索的术语</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%881.19.32.png" alt="截屏2021-01-08 上午1.19.32"></p>
<h3 id="七巧板涂色问题"><a href="#七巧板涂色问题" class="headerlink" title="七巧板涂色问题"></a>七巧板涂色问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">color = []</span><br><span class="line">board = []</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="comment"># 用来判断是否正确涂色</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cheakout</span>():</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_color</span>(<span class="params">n</span>):</span></span><br><span class="line">  <span class="keyword">if</span> n &gt; <span class="number">7</span>:</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> color:</span><br><span class="line">    <span class="keyword">if</span> ckeakout():</span><br><span class="line">      board[n] = i</span><br><span class="line">      make_color(n+<span class="number">1</span>)</span><br><span class="line">      board[n] = -<span class="number">1</span>		<span class="comment"># 恢复现场</span></span><br></pre></td></tr></table></figure>
<h2 id="第八章-回溯法"><a href="#第八章-回溯法" class="headerlink" title="第八章 回溯法"></a>第八章 回溯法</h2><h3 id="回溯法的基本思想"><a href="#回溯法的基本思想" class="headerlink" title="回溯法的基本思想"></a>回溯法的基本思想</h3><p>回溯法的基本做法是<strong>搜索</strong>，或是一种组织得井井有条的，能避免不必要搜索的穷举式搜索法。这种方法适用于解一些组合数相当大的问题。</p>
<p>回溯法在问题的解空间树中，按深度优先策略，从根结点出发搜索解空间树。算法搜索至解空间树的任意一点时，先判断该结点是否包含问题的解。如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯；否则，进入该子树，继续按深度优先策略搜索。</p>
<p><strong>走不通，就掉头。</strong>  </p>
<h3 id="回溯算法递归框架"><a href="#回溯算法递归框架" class="headerlink" title="回溯算法递归框架"></a>回溯算法递归框架</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">try</span>(<span class="keyword">int</span> i)</span><br><span class="line"> &#123;   <span class="keyword">if</span> (i&gt;n) 输出结果;</span><br><span class="line">  		<span class="keyword">else</span> </span><br><span class="line">          <span class="keyword">for</span>(j=下界 ; j&lt;=上界; j++) <span class="comment">//枚举i所有可能的路径</span></span><br><span class="line">          &#123; <span class="keyword">if</span> ( check(j)=<span class="number">1</span>)        <span class="comment">//满足限界函数和约束条件</span></span><br><span class="line">               &#123; a[i]=j;</span><br><span class="line">                  ……            <span class="comment">//其它操作</span></span><br><span class="line">                  <span class="keyword">try</span>(i+ <span class="number">1</span>);&#125;</span><br><span class="line">             <span class="comment">// 回溯前的清理工作(如:a[i]置空值)；</span></span><br><span class="line">           &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="built_in">map</span> = [<span class="number">8</span>][<span class="number">8</span>]</span><br><span class="line"><span class="comment"># 检查状态函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cheakout</span>():</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">queen</span>(<span class="params">x, y</span>):</span></span><br><span class="line">  <span class="keyword">if</span> x == <span class="number">9</span>:</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    <span class="keyword">if</span> cheakout():</span><br><span class="line">      <span class="built_in">map</span>[x+<span class="number">1</span>, i] = <span class="number">1</span></span><br><span class="line">      queen(x+<span class="number">1</span>, i)</span><br><span class="line">      <span class="built_in">map</span>[x+<span class="number">1</span>, i] = <span class="number">0</span>		<span class="comment"># 恢复现场</span></span><br></pre></td></tr></table></figure>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>解空间</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%888.35.04.png" alt="截屏2021-01-08 上午8.35.04"></p>
<p>约束条件：实际上就是定义能否成立的条件</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%888.35.24.png" alt="截屏2021-01-08 上午8.35.24"></p>
<p>限界条件：预估的最大值是否能超过现有的最大值</p>
<p>剪枝</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%888.36.18.png" alt="截屏2021-01-08 上午8.36.18"></p>
<h3 id="最优装载"><a href="#最优装载" class="headerlink" title="最优装载"></a>最优装载</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%888.37.40.png" alt="截屏2021-01-08 上午8.37.40"></p>
<h3 id="最大团问题"><a href="#最大团问题" class="headerlink" title="最大团问题"></a>最大团问题</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%889.18.48.png" alt="截屏2021-01-08 上午9.18.48"></p>
<p>完全图是指每两个节点都有边相连</p>
<p>约束条件：是否能够满足最大团的定义</p>
<p>限界条件：所剩下的所有节点数能否大于现阶段最大的节点数</p>
<h3 id="搜索代价"><a href="#搜索代价" class="headerlink" title="搜索代价"></a>搜索代价</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%888.18.08.png" alt="截屏2021-01-08 上午8.18.08"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%888.18.22.png" alt="截屏2021-01-08 上午8.18.22"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%888.18.40.png" alt="截屏2021-01-08 上午8.18.40"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%888.18.54.png" alt="截屏2021-01-08 上午8.18.54"></p>
<h3 id="回溯法效率"><a href="#回溯法效率" class="headerlink" title="回溯法效率"></a>回溯法效率</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%888.09.35.png" alt="截屏2021-01-08 上午8.09.35"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%888.10.05.png" alt="截屏2021-01-08 上午8.10.05"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%888.10.20.png" alt="截屏2021-01-08 上午8.10.20"></p>
<h2 id="第九章-分支限界"><a href="#第九章-分支限界" class="headerlink" title="第九章 分支限界"></a>第九章 分支限界</h2><h3 id="分支限界的策略"><a href="#分支限界的策略" class="headerlink" title="分支限界的策略"></a>分支限界的策略</h3><p><strong>所谓“分支”是采用广度优先的策略，依次生成E-结点所有分支，也就是所有的儿子结点。</strong></p>
<h3 id="分支限界的三种搜索方式"><a href="#分支限界的三种搜索方式" class="headerlink" title="分支限界的三种搜索方式"></a>分支限界的三种搜索方式</h3><p>1．FIFO搜索 </p>
<p>2．LIFO搜索 </p>
<p>3．优先队列式搜索 </p>
<h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><ul>
<li><strong>一开始，根结点是唯一的活结点，根结点入队。</strong></li>
<li><strong>从活结点队中取出根结点后，作为当前扩展结点。</strong></li>
<li><strong>对当前扩展结点，先从左到右地产生它的所有儿子，用约束条件检查，把所有满足约束函数的儿子加入活结点队列中。</strong></li>
<li><strong>再从活结点表中取出队首结点（队中最先进来的结点）为当前扩展结点，……，直到找到一个解或活结点队列为空为止。</strong></li>
</ul>
<h3 id="LIFO"><a href="#LIFO" class="headerlink" title="LIFO"></a>LIFO</h3><ul>
<li><strong>一开始，根结点入栈。</strong></li>
<li><strong>从栈中弹出一个结点为当前扩展结点。</strong></li>
<li><strong>对当前扩展结点，先从左到右地产生它的所有儿子，用约束条件检查，把所有满足约束函数的儿子入栈;</strong></li>
<li><strong>再从栈中弹出一个结点（栈中最后进来的结点）为当前扩展结点，……，直到找到一个解或栈为空为止。</strong></li>
</ul>
<h3 id="优先队列式搜索"><a href="#优先队列式搜索" class="headerlink" title="优先队列式搜索"></a>优先队列式搜索</h3><ul>
<li><strong>为了加速搜索的进程，可以采用有效的方式选择E-结点进行扩展。</strong></li>
<li><strong>优先队列式搜索，对每一活结点计算一个优先级（某些信息的函数值）</strong><ul>
<li>根据这些优先级，从当前活结点表中优先选择一个优先级最高（最有利）的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</li>
</ul>
</li>
</ul>
<h3 id="最优装载-1"><a href="#最优装载-1" class="headerlink" title="最优装载"></a>最优装载</h3><p>限界问题：<strong>若当前分支的“装载上界”，比现有的最大装载小，则该分支就无需继续搜索。</strong></p>
<p>“装载上界”，容易求解，就是假设装载当前物品以后的所有物品。</p>
<p>如果使用优先队列式分子限界的话，那么将要用最大堆来保存节点，并且不需要堆中没有数据才截止，而是找到叶子节点即可停止</p>
<h3 id="布线问题"><a href="#布线问题" class="headerlink" title="布线问题"></a>布线问题</h3><h3 id="深度优先搜索和广度优先搜索的区别"><a href="#深度优先搜索和广度优先搜索的区别" class="headerlink" title="深度优先搜索和广度优先搜索的区别"></a>深度优先搜索和广度优先搜索的区别</h3><p>​    <strong>深度优先搜索法不全部保留结点，扩展完的结点从数据存储结构栈中弹出删去，在栈中存储的结点数就是解空间树的深度，因此它占用空间较少。所以，当搜索树的结点较多，用其它方法易产生内存溢出时，深度优先搜索不失为一种有效的求解方法。</strong></p>
<p>​    <strong>广度优先搜索算法，一般需存储产生所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题。但广度优先搜索法一般无回溯操作（即入栈和出栈的操作），所以运行速度比深度优先搜索要快些。</strong></p>
<h3 id="回溯法和分支限界法的区别"><a href="#回溯法和分支限界法的区别" class="headerlink" title="回溯法和分支限界法的区别"></a>回溯法和分支限界法的区别</h3><p>n<strong>回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。它们在问题的解空间树T上搜索的方法不同，适合解决的问题也就不同。一般情况下，回溯法的求解目标是找出T中满足约束条件的所有解的方案，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。相对而言，分支限界算法的解空间比回溯法大得多， 因此当内存容量有限时，回溯法成功的可能性更大。</strong></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-08%20%E4%B8%8A%E5%8D%889.59.56.png" alt="截屏2021-01-08 上午9.59.56"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>​      <strong>在处理最优问题时，采用穷举法、回溯法或分支限界法都可以通过利用当前最优解和上界函数加速。仅就对限界剪支的效率而言，优先队列的分支限界法显然要更充分一些。在穷举法中通过上界函数与当前情况下函数值的比较可以直接略过不合要求的情况而省去了更进一步的枚举和判断；回溯法则因为层次的划分，可以在上界函数值小于当前最优解时，剪去以该结点为根的子树，也就是节省了搜索范围；分支限界法在这方面除了可以做到回溯法能做到的之外，同时若采用优先队列的分支限界法，用上界函数作为活结点的优先级，一旦有叶结点成为当前扩展结点，就意味着该叶结点所对应的解即为最优解，可以立即终止其余的过程。在前面的例题中曾说明，优先队列的分支限界法更象是有选择、有目的地进行搜索，时间效率、空间效率都是比较高的。</strong></p>
<h2 id="第十章-概率算法"><a href="#第十章-概率算法" class="headerlink" title="第十章 概率算法"></a>第十章 概率算法</h2><h3 id="使用110的随机数模拟15"><a href="#使用110的随机数模拟15" class="headerlink" title="使用110的随机数模拟15"></a>使用1<del>10的随机数模拟1</del>5</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生成【1， 10】的随机数</span></span><br><span class="line"><span class="string">    :return: 返回【1， 10】之间的随机数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">num = <span class="built_in">int</span>(get_random() / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">    print(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.zkwzkw.top/2021/01/07/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kaiwen zhou">
      <meta itemprop="description" content="the web page to share my code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meredith's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/07/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">算法分析复习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-07 19:44:57" itemprop="dateCreated datePublished" datetime="2021-01-07T19:44:57+08:00">2021-01-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="算法分析复习"><a href="#算法分析复习" class="headerlink" title="算法分析复习"></a>算法分析复习</h1><h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><p><a target="_blank" rel="noopener" href="https://github.com/Meredith2000/execrise_of_algorithm_analysis">https://github.com/Meredith2000/execrise_of_algorithm_analysis</a></p>
<h2 id="考试题型"><a href="#考试题型" class="headerlink" title="考试题型"></a>考试题型</h2><ul>
<li>基础知识 （50%）<ul>
<li>单向选择</li>
<li>判断</li>
</ul>
</li>
<li>分析应用<ul>
<li>分析题</li>
<li>应用题</li>
</ul>
</li>
</ul>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>提供后进先出方式的存取</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>先进先出方式的存取</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>使用指针，将数据块相连接</li>
<li>优点是插入快，删除快</li>
<li>缺点是查找慢</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li>优点是查找、插入、删除都快（如果树保持平衡）</li>
<li>缺点是删除算法复杂</li>
</ul>
<h3 id="红－黑树"><a href="#红－黑树" class="headerlink" title="红－黑树"></a>红－黑树</h3><ul>
<li>查找、插入、删除都快</li>
<li>树总是平衡的</li>
<li>缺点是算法复杂</li>
</ul>
<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h3><p>程序＝数据结构＋算法</p>
<h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><p>算法是解一确定类问题的任意一种特殊的方法</p>
<h3 id="算法的五个重要特性"><a href="#算法的五个重要特性" class="headerlink" title="算法的五个重要特性"></a>算法的五个重要特性</h3><p>确定性、能行性、输入、输出、有穷性/有限性</p>
<h3 id="DCG"><a href="#DCG" class="headerlink" title="DCG"></a>DCG</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 辗转相除法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">bigger, smaller</span>):</span></span><br><span class="line">	<span class="keyword">while</span> bigger % smaller != <span class="number">0</span>:</span><br><span class="line">    temp = bigger % smaller</span><br><span class="line">    bigger = smaller</span><br><span class="line">    smaller = temp</span><br><span class="line">   <span class="keyword">return</span> smaller</span><br></pre></td></tr></table></figure>
<h3 id="算法分析的目的"><a href="#算法分析的目的" class="headerlink" title="算法分析的目的"></a>算法分析的目的</h3><p>通过对算法分析，在把算法变成程序实际运行前，就知道为完成一项任务所设计的算法的好坏，从而运行好算法，改进差算法，避免无益的人力和物力浪费</p>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p><strong>常见的多项式限界函数有：</strong></p>
<p><strong>Ο(1) &lt;</strong> <strong>Ο(logn) &lt;</strong> <strong>Ο(n) &lt;</strong> <strong>Ο(nlogn) &lt;</strong> <strong>Ο(n^2) &lt;</strong> <strong>Ο(n^3)</strong></p>
<p><strong>常见的多项式限界函数有：</strong></p>
<p><strong>Ο(2n) &lt;</strong> <strong>Ο(n！) &lt;</strong> <strong>Ο(n_n)</strong></p>
<h2 id="第二章-算法的基本工具"><a href="#第二章-算法的基本工具" class="headerlink" title="第二章 算法的基本工具"></a>第二章 算法的基本工具</h2><h2 id="第三章-蛮力法"><a href="#第三章-蛮力法" class="headerlink" title="第三章 蛮力法"></a>第三章 蛮力法</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>选择排序、冒泡排序、插入排序、顺序查找、朴素的字符串匹配、枚举法、盲目搜索算法</strong></p>
<h2 id="第四章-贪婪法"><a href="#第四章-贪婪法" class="headerlink" title="第四章 贪婪法"></a>第四章 贪婪法</h2><h3 id="贪婪法的思想"><a href="#贪婪法的思想" class="headerlink" title="贪婪法的思想"></a>贪婪法的思想</h3><p>贪婪算法通过一系列的局部选择来得到一个问题的解。所作的每一个选择都是当前状态下“最优”的选择。</p>
<p>只顾眼前，不管将来</p>
<h3 id="贪婪法获得最优解的条件"><a href="#贪婪法获得最优解的条件" class="headerlink" title="贪婪法获得最优解的条件"></a>贪婪法获得最优解的条件</h3><p>拥有以下两个性质：</p>
<ul>
<li><strong>贪心选择性质</strong><ul>
<li>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到</li>
</ul>
</li>
<li><strong>最优子结构性质</strong><ul>
<li>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</li>
</ul>
</li>
</ul>
<h3 id="计划安排"><a href="#计划安排" class="headerlink" title="计划安排"></a>计划安排</h3><p>见github中的plan.py</p>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-03%20%E4%B8%8A%E5%8D%881.19.46.png" alt="截屏2021-01-03 上午1.19.46"></p>
<h3 id="为什么0-1背包问题不能用贪心算法得到最优解"><a href="#为什么0-1背包问题不能用贪心算法得到最优解" class="headerlink" title="为什么0-1背包问题不能用贪心算法得到最优解?"></a>为什么0-1背包问题不能用贪心算法得到最优解?</h3><p><strong>对于0-1背包问题，贪心选择之所以不能得到最优解是因为在这种情况下，它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包的价值降低了</strong></p>
<h2 id="第五章-动态规划"><a href="#第五章-动态规划" class="headerlink" title="第五章 动态规划"></a>第五章 动态规划</h2><h3 id="动态规划的基本思想"><a href="#动态规划的基本思想" class="headerlink" title="动态规划的基本思想"></a>动态规划的基本思想</h3><p>把求解的问题分成许多阶段或多个子问题，然后按顺序求解各子问题。最后一个子问题就是初始问题的解。</p>
<p><strong>动态规划=贪婪策略+递推(降阶)+存储递推结果</strong></p>
<h3 id="动态规划算法的问题及决策应该具有两个性质"><a href="#动态规划算法的问题及决策应该具有两个性质" class="headerlink" title="动态规划算法的问题及决策应该具有两个性质"></a>动态规划算法的问题及决策应该具有两个性质</h3><ul>
<li><strong>最优化原理</strong><ul>
<li>最佳原则、最优子结构</li>
</ul>
</li>
<li><strong>无后向性</strong><ul>
<li>某阶段状态一旦确定以后，就不受这个状态以后决策的影响。即某状态以后的过程不会影响以前的状态，只与当前状态有关</li>
</ul>
</li>
</ul>
<h3 id="n个矩阵连乘问题"><a href="#n个矩阵连乘问题" class="headerlink" title="n个矩阵连乘问题"></a>n个矩阵连乘问题</h3><p>状态转移方程：</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-03%20%E4%B8%8B%E5%8D%881.17.42.png" alt="截屏2021-01-03 下午1.17.42"></p>
<p>具体代码见仓库</p>
<h3 id="数塔问题"><a href="#数塔问题" class="headerlink" title="数塔问题"></a>数塔问题</h3><p>这里我采用的逆序法，从上到下，选择大的（具体代码见github）</p>
<h2 id="第六章-分治算法"><a href="#第六章-分治算法" class="headerlink" title="第六章 分治算法"></a>第六章 分治算法</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>将整个问题分解成若干个小问题后分而治之，如果分解得到的子问题相对来说还太大，则可反复使用分治策略将这些子问题分成更小的同类型子问题，直至产生出方便求解的子问题，必要时逐步合并这些子问题的解，从而得到问题的解。</p>
<h3 id="同题异策－-“算法”-与“策略”"><a href="#同题异策－-“算法”-与“策略”" class="headerlink" title="同题异策－ “算法” 与“策略”"></a>同题异策－ “算法” 与“策略”</h3><ul>
<li>策略<ul>
<li>一种思想，提出解决问题的思路</li>
<li>从战略高度上面向问题</li>
</ul>
</li>
<li>算法<ul>
<li>对一个/类具体问题的解决方法</li>
<li>面向具体实现，可以用任何方式描述</li>
<li>策略对算法有指导性</li>
<li>在一种策略的指导下，可以有多种不同的算法实现（如排序问题，使用贪婪策略，列出3种有效算法）</li>
</ul>
</li>
</ul>
<h3 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h3><p>见代码仓库</p>
<h3 id="不同算法之间的区别"><a href="#不同算法之间的区别" class="headerlink" title="不同算法之间的区别"></a>不同算法之间的区别</h3><ul>
<li>迭代(递推) <ul>
<li>中心思想：重复使用迭代(递推)公式，根据变量的旧值推出新值；</li>
<li>适用问题：具有明确迭代公式的问题，主要是数值计算等。</li>
</ul>
</li>
<li>贪婪<ul>
<li>中心思想：通过一系列的局部选择来得到一个问题的解，所作的每一步选择：“只顾眼前最优，不管将来好坏” ；</li>
<li>适用问题：<br>1)贪婪选择性质；<br>2)最优子结构性质。</li>
</ul>
</li>
<li>动态规划<ul>
<li>中心思想：把求解的问题分成许多阶段/子问题，然后按顺序求解各阶段/子问题；记录每个阶段决策得到的结果序列。最后阶段的解就是初始问题的解。</li>
<li>适用问题：<br>1)最优子结构； (必须有)<br>2)无后向性；<br>3)子问题重叠性质。 (体现优势)</li>
</ul>
</li>
<li>分治<ul>
<li>中心思想：将整个问题分解成若干个小问题后分而治之；分解，解决，合并。</li>
<li>适用问题：<br>1)问题的规模缩小到一定程度就可容易解决；<br>2)问题可以分解为若干个规模较小的相似问题；<br>3)子问题的解可以合并为原问题的解；<ol start="4">
<li>子问题相互独立</li>
</ol>
</li>
</ul>
</li>
<li>枚举<ul>
<li>中心思想：枚举出问题的所有可行解，找出其中的最优解</li>
<li>适用问题：其它策略难以奏效。</li>
</ul>
</li>
</ul>
<h2 id="第七章-图的搜索"><a href="#第七章-图的搜索" class="headerlink" title="第七章 图的搜索"></a>第七章 图的搜索</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-03%20%E4%B8%8B%E5%8D%883.50.08.png" alt="截屏2021-01-03 下午3.50.08"></p>
<h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-03%20%E4%B8%8B%E5%8D%883.50.43.png" alt="截屏2021-01-03 下午3.50.43"></p>
<h3 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h3><p>当要求解的问题需要在n 个元素的子集中进行搜索，其搜索空间树被称作子集树(subset tree)</p>
<p>这n个元素都在子集中或被选取记为1，不在子集中或被舍去记为0，这样搜索空间为：</p>
<p>(0,0,……,0,0),</p>
<p> (0,0,……,0,1),</p>
<p> (0,0,……,1,0),</p>
<p> (0,0,……,1,1), </p>
<p> ……</p>
<p> (1,1,……,1,1)。</p>
<h3 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h3><p>当要求解的问题需要在n个元素的排列中搜索问题的解时，解空间树被称作排列树(permutation tree)</p>
<p>第一个元素有n 种选择，第二个元素有n-1种选择，第三个元素有n-2种选择，……，第n个元素有1种选择，共计n!个状态。若表示为树形就是一个n度树，这样的树有n! 个叶结点，所以每一个遍历树中所有节点的算法都必须耗时O(n! ) </p>
<p>搜索空间为：</p>
<p> (1,2,3,……,n-1,n),</p>
<p> (2,1,3,……,n-1,n),</p>
<p> (2,3,1,……,n-1,n),</p>
<p> (2,3,4,1,……,n-1,n),</p>
<p> …….</p>
<p> (n,n-1,……,3,2,1)</p>
<h3 id="隐式图"><a href="#隐式图" class="headerlink" title="隐式图"></a>隐式图</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%882.32.51.png" alt="截屏2021-01-07 下午2.32.51"></p>
<h3 id="显示图"><a href="#显示图" class="headerlink" title="显示图"></a>显示图</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%882.34.37.png" alt="截屏2021-01-07 下午2.34.37"></p>
<h2 id="第八章-回溯法"><a href="#第八章-回溯法" class="headerlink" title="第八章 回溯法"></a>第八章 回溯法</h2><h3 id="回溯法的基本思想"><a href="#回溯法的基本思想" class="headerlink" title="回溯法的基本思想"></a>回溯法的基本思想</h3><p>回溯法的基本做法是搜索，按深度优先策略，从根结点出发搜索解空间树，算法搜索至解空间树的任意一点时，先判断该结点是否包含问题的解。如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯；否则，进入该子树，继续按深度优先策略搜索。</p>
<p><strong>走不通，就掉头</strong></p>
<h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><p>见代码仓库</p>
<h3 id="最优装载回溯法"><a href="#最优装载回溯法" class="headerlink" title="最优装载回溯法"></a>最优装载回溯法</h3><p>见代码仓库</p>
<h3 id="重排原理"><a href="#重排原理" class="headerlink" title="重排原理"></a>重排原理</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%883.10.22.png" alt="截屏2021-01-07 下午3.10.22"></p>
<h2 id="第九章-分支限界法"><a href="#第九章-分支限界法" class="headerlink" title="第九章 分支限界法"></a>第九章 分支限界法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>分支搜索法是一种在问题解空间上进行搜索尝试的算法</strong></p>
<p><strong>“分支”是采用广度优先的策略</strong></p>
<h3 id="最优装载问题"><a href="#最优装载问题" class="headerlink" title="最优装载问题"></a>最优装载问题</h3><p><strong>策略：</strong></p>
<ul>
<li>首先将第一艘轮船尽可能装满</li>
<li>将剩余的集装箱装上第二艘轮船。</li>
</ul>
<p>具体见我期末试卷分析</p>
<p><strong>装载上限</strong>：其后将当前最优解作为一个“界”，对上界（或下界）不可能达到（大于）这个界的分支则不去进行搜索，这样就缩小搜索范围，提高了搜索效率</p>
<p><strong>上界函数</strong>：<strong>当前载重量cw+剩余集装箱的重量&lt;=当前最优载重量bestw</strong></p>
<p><strong>FIFO和优先队列式分支限界法——LC-检索的区别</strong>：</p>
<p><strong>由于FIFO搜索或LIFO搜索是盲目地扩展结点，当前最优解距真正的最优解距离较大，作为“界”所起到的剪枝作用很有限，不能有效提高搜索速度。</strong></p>
<p><strong>LC分支-限界算法用堆存储活结点，以保证比较优良的结点先被扩展。且对于LC分支-限界算法，一旦扩展到叶结点就已经找到最优解，可以停止搜索。</strong></p>
<p>采用大根堆，将bestw最大的作为E-节点，当队列空或者是到叶子节点就结束循环</p>
<h3 id="铺线问题"><a href="#铺线问题" class="headerlink" title="铺线问题"></a>铺线问题</h3><p>见代码仓库</p>
<h2 id="第十章-概率算法"><a href="#第十章-概率算法" class="headerlink" title="第十章 概率算法"></a>第十章 概率算法</h2><p>见我代码仓库</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.zkwzkw.top/2021/01/06/os%E8%80%83%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kaiwen zhou">
      <meta itemprop="description" content="the web page to share my code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meredith's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/06/os%E8%80%83%E7%82%B9/" class="post-title-link" itemprop="url">操作系统考点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-06 21:19:06" itemprop="dateCreated datePublished" datetime="2021-01-06T21:19:06+08:00">2021-01-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="操作系统考点总结"><a href="#操作系统考点总结" class="headerlink" title="操作系统考点总结"></a>操作系统考点总结</h1><h2 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h2><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><ul>
<li>并行性是指两个或者多个事件在同一时刻发生</li>
<li>并发性是指两个或者多个事件在同一时间间隔内发生</li>
</ul>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>设计现代OS的主要目标是什么？</p>
<p>（1）有效性 （2）方便性 （3）可扩充性 （4）开放性</p>
</li>
<li><p>OS的作用可表现在哪几个方面？</p>
<p>1）OS作为用户与计算机硬件系统之间的接口 （2）OS作为计算机系统资源的管理者 （3）OS实现了对计算机资源的抽象</p>
</li>
<li><p>何谓脱机I/O和联机I/O？ </p>
<p>脱机I/O是指事先将装有用户程序和数据的纸带或卡片装入纸带输入机或卡片机，在外围机的控制下，把纸带或卡片上的数据或程序输入到磁带上。该方式下的输入输出由外围 机控制完成，是在脱离主机的情况下进行的。 而联机I/O方式是指程序和数据的输入输出都是在主机的直接控制下进行的</p>
</li>
<li><p>为什么要引入实时OS？</p>
<p>实时操作系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。引入实时OS是为了满足应用的需求，更好地满足实时控制领域和实时信息处理领域的需要。 </p>
</li>
<li><p>处理机管理有哪些主要功能？它们的主要任务是什么？</p>
<p>处理机管理的主要功能是：进程管理、进程同步、进程通信和处理机调度； 进程管理：为作业创建进程，撤销已结束进程，控制进程在运行过程中的状态转换。进程同步：为多个进程（含线程）的运行进行协调。 通信：用来实现在相互合作的进程之间的信息交换。 处理机调度： （1）作业调度。从后备队里按照一定的算法，选出若干个作业，为他们分配运行所需的资源（首选是分配内存）。 （2）进程调度：从进程的就绪队列中，按照一定算法选出一个进程，把处理机分配给它，并设臵运行现场，使进程投入执行。</p>
</li>
<li><p>什么是微内核OS</p>
<p>1）足够小的内核2）基于客户/服务器模式3）应用机制与策略分离原理4）采用面向对象技术。</p>
</li>
<li><p>微内核操作系统具有哪些优点？它为何能有这些优点？</p>
<p>1）提高了系统的可扩展性2）增强了系统的可靠性3）可移植性4）提供了对分布式系统的支持  5）融入了面向对象技术</p>
</li>
</ul>
<h2 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章 进程的描述与控制"></a>第二章 进程的描述与控制</h2><h3 id="重要概念-1"><a href="#重要概念-1" class="headerlink" title="重要概念"></a>重要概念</h3><h4 id="前驱图-important"><a href="#前驱图-important" class="headerlink" title="前驱图 important"></a>前驱图 important</h4><p>前驱图是一个<strong>有向无循环图</strong>，用来面描述进程之间执行的先后顺序，每个节点可以表示一个程序段</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-25%20%E4%B8%8B%E5%8D%887.33.52.png" alt="截屏2020-12-25 下午7.33.52"></p>
<h4 id="程序顺序执行的特点-important"><a href="#程序顺序执行的特点-important" class="headerlink" title="程序顺序执行的特点 important"></a>程序顺序执行的特点 important</h4><ul>
<li><p><strong>顺序性</strong></p>
<p>处理机的操作严格按照程序所规定的顺序执行，即每一操作必须在上一个操作结束之后开始。</p>
</li>
<li><p><strong>封闭性</strong></p>
<p>程序是在封闭的环境下执行的，即程序运行时独占全机资源，资源的状态(除初始状态外)只有本程序才能改变它。程序一旦开始执行，其执行结果不受外界因素影响。</p>
</li>
<li><p><strong>可再现性</strong></p>
<p>只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是“停停走走”地执行，都将获得相同的结果。</p>
</li>
</ul>
<h4 id="程序并发执行时的特征-important"><a href="#程序并发执行时的特征-important" class="headerlink" title="程序并发执行时的特征 important"></a>程序并发执行时的特征 important</h4><ul>
<li><p><strong>间断性</strong></p>
<p>程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致 使在这些并发执行的程序之间，形成了相互制约的关系。</p>
</li>
<li><p><strong>失去封闭性</strong></p>
<p>程序在并发执行时，是多个程序共享系统中的各种资源，因而这些资源的状态将由多 个程序来改变，致使程序的运行失去了封闭性。这样，某程序在执行时，必然会受到其它 程序的影响。</p>
</li>
<li><p><strong>不可再现性</strong></p>
<p>程序在并发执行时，由于失去了封闭性，也将导致其再失去可再现性。</p>
</li>
</ul>
<h4 id="进程定义-important"><a href="#进程定义-important" class="headerlink" title="进程定义 important"></a>进程定义 important</h4><ul>
<li>进程是程序的一次动态执行</li>
<li>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</li>
</ul>
<h4 id="进程的特征-important"><a href="#进程的特征-important" class="headerlink" title="进程的特征 important"></a>进程的特征 important</h4><ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
<li>结构性</li>
</ul>
<h4 id="进程的三种状态-important"><a href="#进程的三种状态-important" class="headerlink" title="进程的三种状态 important"></a>进程的三种状态 important</h4><ul>
<li><strong>就绪状态</strong></li>
<li><strong>执行状态</strong></li>
<li><strong>阻塞状态</strong></li>
</ul>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-25%20%E4%B8%8B%E5%8D%887.49.21.png" alt="截屏2020-12-25 下午7.49.21"></p>
<h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><p>进程控制一般是由OS的内核中的<strong>原语</strong>来实现的</p>
<h4 id="两种形式的制约关系-important"><a href="#两种形式的制约关系-important" class="headerlink" title="两种形式的制约关系 important"></a>两种形式的制约关系 important</h4><ul>
<li>间接相互制约关系（资源共享关系）===》打印机，磁带机，CPU，I/O</li>
<li>直接相互制约关系（相互合作关系）===》生产者消费者</li>
</ul>
<h4 id="临界资源-important"><a href="#临界资源-important" class="headerlink" title="临界资源 important"></a>临界资源 important</h4><p>指的是：<strong>一次仅允许一个进程访问的资源</strong></p>
<p><strong>引起不可再现性是因为临界资源没有互斥访问。</strong></p>
<h4 id="同步机制应遵循的规则-important"><a href="#同步机制应遵循的规则-important" class="headerlink" title="同步机制应遵循的规则 important"></a>同步机制应遵循的规则 important</h4><ul>
<li><p><strong>空闲让进</strong></p>
<p>当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源。</p>
</li>
<li><p><strong>忙则等待</strong></p>
<p>当已有进程进入临界区时，表明临界资源正在被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。</p>
</li>
<li><p><strong>有限等待</strong></p>
<p>对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态。</p>
</li>
<li><p><strong>让权等待</strong></p>
<p>当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。</p>
</li>
</ul>
<h4 id="整型信号量-important"><a href="#整型信号量-important" class="headerlink" title="整型信号量 important"></a>整型信号量 important</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait(S)&#123;			<span class="comment">// P操作</span></span><br><span class="line">  <span class="keyword">while</span>(S &lt;= <span class="number">0</span>);		<span class="comment">// do no-op</span></span><br><span class="line">  S--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(S)&#123;		<span class="comment">// V操作</span></span><br><span class="line">  S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两个信号量分别表示等待信号（P操作）和释放信号（V操作），他们都是原子操作，意味着他们都不能被打断</p>
<p>下面是PV操作的过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wait(S);		<span class="comment">// 等待信号S</span></span><br><span class="line"><span class="comment">// code executing</span></span><br><span class="line">signal(S);	<span class="comment">// 释放信号S</span></span><br></pre></td></tr></table></figure>
<p>只能用来解决一类资源，一个人使用</p>
<h4 id="记录型信号量-important"><a href="#记录型信号量-important" class="headerlink" title="记录型信号量 important"></a>记录型信号量 important</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义信号量的数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;			<span class="comment">// 剩余资源的个数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span> *<span class="title">list</span>;</span>		<span class="comment">// 进程的等待序列</span></span><br><span class="line">&#125;semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作</span></span><br><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">  S-&gt;value--;</span><br><span class="line">  <span class="keyword">if</span>(s-&gt;value &lt; <span class="number">0</span>) block(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V操作</span></span><br><span class="line">singal(semaphore *S)&#123;</span><br><span class="line">  S-&gt;value++;</span><br><span class="line">  <span class="keyword">if</span>(S-&gt;value &lt;= <span class="number">0</span>) wakeup(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AND型信号量-important"><a href="#AND型信号量-important" class="headerlink" title="AND型信号量 important"></a>AND型信号量 important</h4><p>P操作</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-27%20%E4%B8%8B%E5%8D%882.10.17.png" alt="截屏2020-12-27 下午2.10.17"></p>
<p>V操作</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-27%20%E4%B8%8B%E5%8D%882.10.28.png" alt="截屏2020-12-27 下午2.10.28"></p>
<h4 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h4><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-27%20%E4%B8%8B%E5%8D%882.13.21.png" alt="截屏2020-12-27 下午2.13.21"></p>
<h4 id="利用信号量实现前驱关系-important"><a href="#利用信号量实现前驱关系-important" class="headerlink" title="利用信号量实现前驱关系 important"></a>利用信号量实现前驱关系 important</h4><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-27%20%E4%B8%8B%E5%8D%882.14.16.png" alt="截屏2020-12-27 下午2.14.16"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Var a,b,c,d,e,f,g:semaphore: =<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>; </span><br><span class="line">begin</span><br><span class="line">	parbegin</span><br><span class="line">    begin S1; signal(a); signal(b); end;</span><br><span class="line">    <span class="function">begin <span class="title">wait</span><span class="params">(a)</span></span>; S2; signal(c); signal(d); end; </span><br><span class="line">		<span class="function">begin <span class="title">wait</span><span class="params">(b)</span></span>; S3; signal(e); end;</span><br><span class="line">    <span class="function">begin <span class="title">wait</span><span class="params">(c)</span></span>; S4; signal(f); end;</span><br><span class="line">    <span class="function">begin <span class="title">wait</span><span class="params">(d)</span></span>; S5; signal(g); end;</span><br><span class="line">    <span class="function">begin <span class="title">wait</span><span class="params">(e)</span></span>; wait(f); wait(g); S6; end;</span><br><span class="line">	parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="生产者和消费者问题-important"><a href="#生产者和消费者问题-important" class="headerlink" title="生产者和消费者问题 important"></a>生产者和消费者问题 important</h4><p><strong>使用记录型信号量解决</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一开始一定是闲置资源，所以mutex = 1</span></span><br><span class="line"><span class="comment">// 由于一开始缓存区什么都没有，所以empty = n，表示有n个空位</span></span><br><span class="line"><span class="comment">// 同理，full = 0，表示缓存区什么都没有</span></span><br><span class="line">Var mutex，empty，full: semaphore:=<span class="number">1</span>,n,<span class="number">0</span>; </span><br><span class="line">buffer:<span class="built_in">array</span>[<span class="number">0</span>，...，n<span class="number">-1</span>] of item; </span><br><span class="line">in，out: integer:=<span class="number">0</span>，<span class="number">0</span>;</span><br><span class="line">begin</span><br><span class="line">	parbegin </span><br><span class="line">  <span class="comment">// 生产者</span></span><br><span class="line">      proceducer: begin</span><br><span class="line">      repeat</span><br><span class="line">      producer an item nextp;</span><br><span class="line">			<span class="comment">// 两个wait不能调换顺序</span></span><br><span class="line">      wait(empty);			<span class="comment">// 等待有空位</span></span><br><span class="line">      wait(mutex);			<span class="comment">// 等待互斥信号量</span></span><br><span class="line">      buffer(in):=nextp;</span><br><span class="line">      in:=(in+<span class="number">1</span>) mod n; </span><br><span class="line">      signal(mutex); </span><br><span class="line">      signal(full);</span><br><span class="line">      until <span class="literal">false</span>;</span><br><span class="line">			end</span><br><span class="line">  <span class="comment">// 消费者</span></span><br><span class="line">    consumer: begin</span><br><span class="line">      repeat</span><br><span class="line">			<span class="comment">// 两个wait不能调换顺序</span></span><br><span class="line">      wait(full);			<span class="comment">// 等待有物品</span></span><br><span class="line">      wait(mutex); 		<span class="comment">// 等待互斥信号量</span></span><br><span class="line">      nextc:=buffer(out); </span><br><span class="line">      out:=(out+<span class="number">1</span>) mod n; </span><br><span class="line">      signal(mutex); </span><br><span class="line">      signal(empty);</span><br><span class="line">      consumer the item in nextc;</span><br><span class="line">      until <span class="literal">false</span>; </span><br><span class="line">      end</span><br><span class="line">	parend</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>使用AND信号量解决</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Var mutex，empty，full: semaphore:=<span class="number">1</span>，n，<span class="number">0</span>; </span><br><span class="line">	buffer:<span class="built_in">array</span>[<span class="number">0</span>，...，n<span class="number">-1</span>] of item;</span><br><span class="line">	in out: integer:=<span class="number">0</span>，<span class="number">0</span>;</span><br><span class="line">begin</span><br><span class="line">  parbegin</span><br><span class="line">  <span class="comment">// 生产者</span></span><br><span class="line">		producer: begin </span><br><span class="line">      repeat</span><br><span class="line">		  produce an item in nextp;</span><br><span class="line">			Swait(empty，mutex);</span><br><span class="line">			buffer(in):=nextp; </span><br><span class="line">			in:=(in+<span class="number">1</span>)mod n; </span><br><span class="line">			Ssignal(mutex，full);</span><br><span class="line">		until <span class="literal">false</span>; </span><br><span class="line">	end</span><br><span class="line">  <span class="comment">// 消费者</span></span><br><span class="line">  consumer:begin </span><br><span class="line">    repeat</span><br><span class="line">      Swait(full，mutex); </span><br><span class="line">      Nextc:=buffer(out); </span><br><span class="line">      Out:=(out+<span class="number">1</span>) mod n; </span><br><span class="line">      Ssignal(mutex，empty); </span><br><span class="line">      consumer the item in nextc;</span><br><span class="line">    until <span class="literal">false</span>; </span><br><span class="line">  end</span><br><span class="line">	parend </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="哲学家进餐问题-important"><a href="#哲学家进餐问题-important" class="headerlink" title="哲学家进餐问题 important"></a>哲学家进餐问题 important</h4><p><strong>使用记录型信号解决</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  wait(chopstick[i]);</span><br><span class="line">	wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// eat</span></span><br><span class="line">  ...</span><br><span class="line">  signal(chopstick[i]);</span><br><span class="line">  signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// think</span></span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p><strong>上面这种方法可能会引起死锁</strong></p>
<p><strong>使用AND型信号量解决</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// think</span></span><br><span class="line">  ...</span><br><span class="line">  Swait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>, chopstick[i]);		<span class="comment">// 同时拿到两个筷子</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// eat</span></span><br><span class="line">  ...</span><br><span class="line">  Ssignal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>, chopstick[i]);		<span class="comment">// 同时释放两个筷子</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<h4 id="读写者问题-important"><a href="#读写者问题-important" class="headerlink" title="读写者问题 important"></a>读写者问题 important</h4><p><strong>使用记录型信号量解决</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许多个读者读，</span></span><br><span class="line"><span class="comment">// 但是只允许一个写者进行写</span></span><br><span class="line"><span class="comment">// 也循序读者和写者一起访问</span></span><br><span class="line">Var rmutex，wmutex: semaphore:=<span class="number">1</span>,<span class="number">1</span>;</span><br><span class="line">Readcount: integer:=<span class="number">0</span>; 		<span class="comment">// 表示正在进行读操作的进程个数</span></span><br><span class="line">begin</span><br><span class="line">parbegin</span><br><span class="line">  <span class="comment">// 读者</span></span><br><span class="line">	Reader: begin </span><br><span class="line">    repeat</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		<span class="keyword">if</span> readcount=<span class="number">0</span> then wait(wmutex);		<span class="comment">// 没有任何东西可以读，等待写进程释放</span></span><br><span class="line">			Readcount:=Readcount+<span class="number">1</span>;</span><br><span class="line">		signal(rmutex);</span><br><span class="line">		perform read operation;</span><br><span class="line">		wait(rmutex);</span><br><span class="line">		readcount:=readcount<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> readcount=<span class="number">0</span> then signal(wmutex); </span><br><span class="line">			signal(rmutex);</span><br><span class="line">		until <span class="literal">false</span>; </span><br><span class="line">		end</span><br><span class="line">  <span class="comment">// 写者</span></span><br><span class="line">	writer: begin</span><br><span class="line">    repeat</span><br><span class="line">			wait(wmutex);</span><br><span class="line">			perform write operation; </span><br><span class="line">			signal(wmutex);</span><br><span class="line">		until <span class="literal">false</span>; </span><br><span class="line">	end</span><br><span class="line">parend </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="引入进程和线程的目的-important"><a href="#引入进程和线程的目的-important" class="headerlink" title="引入进程和线程的目的 important"></a>引入进程和线程的目的 important</h4><ul>
<li><p>进程</p>
<p>目的是为了使多个程序能够并发的执行，以提高资源利用率和系统吞吐量</p>
</li>
<li><p>线程</p>
<p>为了减少应用程序在并发执行是所付出的时空开销，使OS具有更好的并发性</p>
</li>
</ul>
<h4 id="进程和线程的区别-important"><a href="#进程和线程的区别-important" class="headerlink" title="进程和线程的区别 important"></a>进程和线程的区别 important</h4><ul>
<li><strong>调度的基本单位</strong><ul>
<li>进程是资源拥有的基本单位</li>
<li>线程是调度和分派的基本单位</li>
</ul>
</li>
<li><strong>并发性（调度性）</strong><ul>
<li>多个进程是可以并发执行的</li>
<li>一个进程中的多个线程也可以并发执行</li>
</ul>
</li>
<li><strong>拥有资源</strong><ul>
<li>进程可以拥有资源，并作为系统中拥有资源的一个基本单位</li>
<li>线程本身不拥有系统资源，而是仅有一点必不可少的，能保证独立运行的资源</li>
</ul>
</li>
<li><strong>独立性</strong><ul>
<li>不同进程之间的独立性高</li>
<li>统一进程中的不同线程之间的独立性低</li>
</ul>
</li>
<li><strong>系统开销</strong><ul>
<li>进程的开销大</li>
<li>线程的开销小</li>
</ul>
</li>
<li>支持多处理机系统<ul>
<li>多线程应用可以吧多个线程分配带多个处理机上(CPU)</li>
</ul>
</li>
</ul>
<h4 id="线程的三个状态"><a href="#线程的三个状态" class="headerlink" title="线程的三个状态"></a>线程的三个状态</h4><ul>
<li>执行状态</li>
<li>就绪状态</li>
<li>阻塞状态</li>
</ul>
<h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>画出下面四条语句的前趋图:S1=a：=x+y;S2=b：=z+1;S3=c：=a-b； S4=w：=c+1;</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.27.23.png" alt="截屏2020-12-28 上午10.27.23"></p>
</li>
<li><p>为什么程序并发执行会产生间断性特征</p>
<p>程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的进程之间，形成了相互制约的关系，从而也就使得进程在执行期间出现间断性。</p>
</li>
<li><p>程序并发执行时为什么会失去封闭性和可再现性？</p>
<p>因为程序并发执行时，是多个程序共享系统中的各种资源，因而这些资源的状态是由多个程序来改变，致使程序的运行失去了封闭性。而程序一旦失去了封闭性也会导致其再失去可再现性。</p>
</li>
<li><p>试从动态性，并发性和独立性上比较进程和程序?</p>
<p>a.动态性是进程最基本的特性，可表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，以及由撤销而消亡，因而进程由一定的生命期；而程序只是一组有序指令的集合，是静态实体。b.并发性是进程的重要特征，同时也是OS的重要特征。引入进程的目的正是为了使其程序能和其它建立了进程的程序并发执行，而程序本身是不能并发执行的。c.独立性是指进程实体是一个能独立运行的基本单位，同时也是系统中独立获得资源和独立调度的基本单位。而对于未建立任何进程的程序，都不能作为一个独立的单位来运行。</p>
</li>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.30.12.png" alt="截屏2020-12-28 上午10.30.12"></p>
</li>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.30.52.png" alt="截屏2020-12-28 上午10.30.52"></p>
</li>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.31.06.png" alt="截屏2020-12-28 上午10.31.06"></p>
</li>
<li><p>在进行进程切换时，所要保存的处理机状态信息有哪些？ </p>
<p>进行进程切换时，所要保存的处理机状态信息有： （1）进程当前暂存信息 （2）下一指令地址信息 （3）进程状态信息 （4）过程和系统调用参数及调用地址信息。</p>
</li>
<li><p>为什么要在OS中引入线程？</p>
<p>在OS中引入进程的目的，是为了使多个程序能并发执行，以提高资源利用率和系 统吞吐量。在OS中再引入线程，则是为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性。 </p>
</li>
<li><p>试说明线程具有哪些属性？</p>
<p>（1)轻型实体（2）独立调度和分派的基本单位（3）可并发执行（4）共享进程资源。</p>
</li>
<li><p>试从调度性，并发性，拥有资源及系统开销方面对进程和线程进行比较.</p>
<p>a.调度性。在传统的操作系统中，拥有资源的基本单位和独立调度、分派的基本单位都是进程，在引入线程的OS中，则把线程作为调度和分派的基本单位，而把进程作为资源拥有的基本单位；b.并发性。在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间，亦可并发执行，因而使OS具有更好的并发性；c.拥有资源。无论是传统的操作系统，还是引入了线程的操作系统，进程始终是拥有资源的一个基本单位，而线程除了拥有一点在运行时必不可少的资源外，本身基本不拥有系统资源，但它可以访问其隶属进程的资源； d.开销。由于创建或撤销进程时，系统都要为之分配和回收资源，如内存空间等，进程切换时所要保存和设置的现场信息也要明显地多于线程，因此，操作系统在创建、撤消和切换进程时所付出的开销将显著地大于线程。</p>
</li>
</ul>
<h2 id="第三章-处理机调度与死锁"><a href="#第三章-处理机调度与死锁" class="headerlink" title="第三章 处理机调度与死锁"></a>第三章 处理机调度与死锁</h2><h3 id="重要概念-2"><a href="#重要概念-2" class="headerlink" title="重要概念"></a>重要概念</h3><h4 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h4><ul>
<li>高级调度</li>
<li>低级调度</li>
<li>中级调度</li>
</ul>
<h4 id="关于周转时间的几个概念以及计算-important"><a href="#关于周转时间的几个概念以及计算-important" class="headerlink" title="关于周转时间的几个概念以及计算 important"></a>关于周转时间的几个概念以及计算 important</h4><p><strong>周转时间</strong>指的是：<strong>进程完成时间 - 进程开始等待的时间</strong></p>
<p><strong>代权周转时间</strong>指的是：<strong>周转时间/进程执行所需要的时间</strong></p>
<p><strong>平均代权周转时间</strong>指的是：<strong>代权周转时间/进程的个数</strong></p>
<h4 id="先来先服务（FCFS）important"><a href="#先来先服务（FCFS）important" class="headerlink" title="先来先服务（FCFS）important"></a>先来先服务（FCFS）important</h4><p><strong>可以用于作业调度或者进程调度</strong></p>
<p>不管作业执行的长短，谁先进来就先执行谁</p>
<p>利于长作业（进程），不利于短作业（进程）</p>
<h4 id="短作业优先（非抢占式）（SJF）-important"><a href="#短作业优先（非抢占式）（SJF）-important" class="headerlink" title="短作业优先（非抢占式）（SJF） important"></a>短作业优先（非抢占式）（SJF） important</h4><p><strong>可以用于作业调度或者进程调度</strong></p>
<p>作业越短，优先级越高</p>
<p>缺点：</p>
<ul>
<li>需要预支作业运行的时间</li>
<li>对长作业非常不利</li>
</ul>
<h4 id="短作业优先（抢占式）（SPF）-important"><a href="#短作业优先（抢占式）（SPF）-important" class="headerlink" title="短作业优先（抢占式）（SPF） important"></a>短作业优先（抢占式）（SPF） important</h4><p>与非抢占式基本相同，<strong>但是队列中有小的作业时会抢占当前的作业去执行</strong></p>
<h4 id="优先级调度（PSA）important"><a href="#优先级调度（PSA）important" class="headerlink" title="优先级调度（PSA）important"></a>优先级调度（PSA）important</h4><p>根据优先权的大小，来先后执行任务</p>
<h4 id="轮转调度算法（RR）"><a href="#轮转调度算法（RR）" class="headerlink" title="轮转调度算法（RR）"></a>轮转调度算法（RR）</h4><p><strong>适用于进程调度</strong></p>
<p>根据FCFS，将所有就绪进程排成一个就绪队列，按照一定的时间片来依次执行</p>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p>静态优先级：在整个过程中，优先级不会发生变化</p>
<p>动态优先级：在整个过程中，优先级会发生变化</p>
<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-27%20%E4%B8%8B%E5%8D%884.05.17.png" alt="截屏2020-12-27 下午4.05.17"></p>
<p><strong>在就绪队列中采用FCFS，就绪队列之间采用优先级调度算法</strong></p>
<h4 id="最早截止时间优先（EDF）"><a href="#最早截止时间优先（EDF）" class="headerlink" title="最早截止时间优先（EDF）"></a>最早截止时间优先（EDF）</h4><p>截止时间越早，优先级越高</p>
<h4 id="最低松弛度优先算法（LLF）"><a href="#最低松弛度优先算法（LLF）" class="headerlink" title="最低松弛度优先算法（LLF）"></a>最低松弛度优先算法（LLF）</h4><p><strong>松弛度</strong>：必须完成的时间-本身的运行时间-当前时间</p>
<p>松弛度越低，表示任务越紧急，要优先执行</p>
<p><strong>切换点：</strong></p>
<ul>
<li>松弛度为0</li>
<li>进程结束</li>
</ul>
<h4 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h4><ul>
<li>竞争不可抢占性资源引起死锁</li>
<li>竞争可消耗资源引起死锁</li>
<li>进程推进顺序不当引起死锁</li>
</ul>
<h4 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h4><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁</p>
<h4 id="产生死锁的必要条件-important"><a href="#产生死锁的必要条件-important" class="headerlink" title="产生死锁的必要条件 important"></a>产生死锁的必要条件 important</h4><p><strong>必须要同时满足以下四个条件，才会发生死锁</strong></p>
<ul>
<li><p><strong>互斥条件</strong></p>
<p>指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由 一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源 的进程用毕释放。</p>
</li>
<li><p><strong>请求和保持条件</strong></p>
<p>指进程已经保持了至少一个资源，但又提出了新的资源请求，而 该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p>
</li>
<li><p><strong>不可抢占条件</strong></p>
<p>指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完 时由自己释放。</p>
</li>
<li><p><strong>循环等待条件</strong></p>
<p>指在发生死锁时，必然存在一个进程——资源的环形链，即进程集 合{P0，P1，P2，…，Pn}中的 P0 正在等待一个 P1 占用的资源;P1 正在等待 P2 占用的资源，……， Pn 正在等待已被 P0 占用的资源。</p>
</li>
</ul>
<h4 id="处理死锁的方法-important"><a href="#处理死锁的方法-important" class="headerlink" title="处理死锁的方法 important"></a>处理死锁的方法 important</h4><ul>
<li><p><strong>预防死锁</strong></p>
<p>是一种较简单和直观的事先预防的方法。该方法是通过设置某些限制 条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但由于所施加的限制条件往往太严格，因而可能 会导致系统资源利用率和系统吞吐量降低。</p>
</li>
<li><p><strong>避免死锁</strong></p>
<p>该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施 去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统 进入不安全状态，从而避免发生死锁。这种方法只需事先施加较弱的限制条件，便可获得 较高的资源利用率及系统吞吐量，但在实现上有一定的难度。目前在较完善的系统中常用 此方法来避免发生死锁。</p>
</li>
<li><p><strong>检测死锁</strong></p>
<p>这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进 入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及 时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源; 然后，采取适当措施， 从系统中将已发生的死锁清除掉。</p>
</li>
<li><p><strong>解除死锁</strong></p>
<p>这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须 将进程从死锁状态中解脱出来。常用的实施方法是撤消或挂起一些进程，以便回收一些资 源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁 的检测和解除措施有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</p>
</li>
</ul>
<h4 id="利用银行家算法来避免死锁-impotrant"><a href="#利用银行家算法来避免死锁-impotrant" class="headerlink" title="利用银行家算法来避免死锁 impotrant"></a>利用银行家算法来避免死锁 impotrant</h4><p><strong>几个数据结构</strong></p>
<ul>
<li><p><strong>可利用资源向量Available</strong></p>
<p>这是一个含有 m 个元素的数组，其中的每一个元素代 表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值 随该类资源的分配和回收而动态地改变。如果 Available[j]=K，则表示系统中现有 R j 类资源 K个。</p>
</li>
<li><p><strong>最大需求矩阵Max</strong></p>
<p>这是一个 n×m 的矩阵，它定义了系统中 n 个进程中的每一个 进程对 m 类资源的最大需求。如果 Max[i,j]=K，则表示进程 i 需要 Rj 类资源的最大数目 为K。</p>
</li>
<li><p><strong>分配矩阵Allocation</strong></p>
<p>这也是一个 n×m 的矩阵，它定义了系统中每一类资源当前已 分配给每一进程的资源数。如果 Allocation[i,j]=K，则表示进程 i 当前已分得 R j 类资源的数 目为 K。</p>
</li>
<li><p><strong>需求矩阵Need</strong></p>
<p>这也是一个 n×m 的矩阵，用以表示每一个进程尚需的各类资源数。 如果 Need[i,j]=K，则表示进程 i 还需要 R j 类资源 K 个，方能完成其任务。</p>
</li>
</ul>
<p>三个矩阵满足下面这个关系：</p>
<p><strong>Need[i, j]=Max[i, j]-Allocation[i, j]</strong></p>
<h3 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>高级调度与低级调度的主要任务是什么？为什么要引入中级调度？</p>
<p>1）高级调度主要任务是用于决定把外存上处于后备队列中的那些作业调入内存，并为它们创建进程，分配必要的资源，然后再将新创建的进程排在就绪队列上，准备执行。 （2）低级调度主要任务是决定就绪队列中的哪个进程将获得处理机，然后由分派程序执行把处理机分配给该进程的操作。 （3）引入中级调度的主要目的是为了提高内存的利用率和系统吞吐量。为此，应使那些暂时不能运行的进程不再占用宝贵的内存空间，而将它们调至外存上去等待，称此时的进程状态为就绪驻外存状态或挂起状态。当这些进程重又具备运行条件，且内存又稍有空闲时，由中级调度决定，将外存上的那些重又具备运行条件的就绪进程重新调入内存，并修改其状态为就绪状态，挂在就绪队列上，等待进程调度。</p>
</li>
<li><p>试说明低级调度的主要功能。</p>
<p>（1）保存处理机的现场信息（2）按某种算法选取进程（3）把处理机分配给进程。</p>
</li>
<li><p>在抢占调度方式中，抢占的原则是什么？</p>
<p>剥夺原则有： （1）时间片原则 各进程按时间片运行，当一个时间片用完后，便停止该进程的执行而重新进行调度。这种原则适用于分时系统、大多数实时系统，以及要求较高的批处理系统。 （2）优先权原则 通常是对一些重要的和紧急的作业赋予较高的优先权。当这种作业到达时，如果其优先权比正在执行进程的优先权高，便停止正在执行的进程，将处理机分配给优先权高的进程，使之执行。 （3）短作业（进程）优先原则 当新到达的作业（进程）比正在执行的作业（进程）明显地短时，将剥夺长作业（进程）的执行，将处理机分配给短作业（进程），使之优先执行。</p>
</li>
<li><p>选择调度方式和调度算法时，应遵循的准则是什么？</p>
<p>应遵循的准则有 （1）面向用户的准则：周转时间短，响应时间快，截止时间的保证，优先权准则。 （2）面向系统的准则：系统吞吐量高，处理机利用率好，各类资源的平衡利用。</p>
</li>
<li><p>何谓静态和动态优先权？确定静态优先权的依据是什么？</p>
<p>静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。动态优先权是指，在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。 确定静态优先权的依据是： （1）进程类型，通常系统进程的优先权高于一般用户进程的优先权。 （2）进程对资源的需要。 （3）用户要求，用户进程的紧迫程度及用户所付费用的多少来确定优先权的。</p>
</li>
<li><p>试比较FCFS和SPF两种进程调度算法。</p>
<p>FCFS算法按照作业提交或进程变为就绪状态的先后次序，分派CPU。当前作业或进程占有CPU，直到执行完或阻塞，才让出CPU。在作业或进程唤醒后，并不立即恢复执行，通常等到当前作业或进程让出CPU。FCFS比较有利于长作业，而不利于短作业；有利于CPU繁忙的作业，而不利于I/O繁忙的作业。SPF有利于短进程调度，是从就绪队列中选出一估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时，再重新调度。比FCFS改善了平均周转时间和平均带权周转时间，缩短了作业的等待时间，提高了系统的吞吐量。但SPF有其不容忽视的缺点：该算法对长作业不利；完全未考虑作业的紧迫程度，因而不能保证紧迫性作业（进程）会被及时处理；用户可能会有意无意地干扰作业的运行时间，致使该算法不一定能真正做到短作业优先调度。</p>
</li>
<li><p>为什么说多级反馈队列调度算法能较好地满足各方面用户的需要？</p>
<p>1）对于终端型用户来说，他们提交的大多属于较小的交互型作业，系统只要能使这些作业（进程）在第一队列所规定的时间片内完成，便可使终端型作业用户都感到满意。 （2）对短批处理作业用户来说，在第一队列中执行一个时间片或至多只需在第二队列和第三队列中各执行一个时间片即可完成。 （3）对长批处理作业用户来说，只要将作业依次在第1，2，„„，n个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。</p>
</li>
<li><p>按调度方式可将实时调度算法分为哪几种？ </p>
<p>按调度方式可将实时调度算法分为两大类四小类： （1）非抢占式调度算法：①非抢占式轮转调度算法；②非抢占式优先调度算法； （2）抢占式调度算法：①基于时钟中断的抢占式优先权调度算法；②立即抢占的优先权调度算法。</p>
</li>
<li><p>什么是最早截止时间优先调度算法？举例说明之。</p>
<p>在系统中保持一个实时任务就绪队列，该队列按各任务截止时间的早晚排序，截止时间愈早的优先级愈高，在队列中排列愈靠前，调度程序在选择任务时，总是选择就绪队列中的第一个任务，为之分配处理机，使之投入运行。 例：四个非周期任务，它们先后到达。系统首先调度任务1执行，在任务1执行期间，任务2、3又先后到达。由于任务3的开始截止时间早于任务2，系统在任务1后将调度任务3执行。在此期间又到达作业4，其开始截止时间仍是早于任务2的，在任务3执行完后，系统又调度任务4的执行，最后才调度任务2执行。</p>
</li>
<li><p>何谓死锁？产生死锁的原因和必要条件是什么？</p>
<p>所谓死锁，是指多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进。 产生死锁的原因： （1） 竞争资源，当系统中供多个进程所共享的资源，不足以同时满足它们的 需要时，引起它们对资源的竞争而产生死锁； （2） 进程推进顺序非法，进程在运行过程中，请求和释放资源的顺序不当， 导致进程死锁。 产生死锁的必要条件： （1） 互斥条件 进程对所分配到的资源进行排他性使用。如果此时还有其他进程请求该资源，请求者只能阻塞，直到占有该资源的进程释放该资源。 （2） 请求和保持条件 进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又已被其他进程占有，此时请求进程阻塞，但请求进程又对已经获得的其他资源保持不放。 （3） 不剥夺条件 进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完后由自己释放。 （4） 环路等待条件 在发生死锁时，必然存在一个进程——资源的环形链。</p>
</li>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.38.05.png" alt="截屏2020-12-28 上午10.38.05"><br><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.38.09.png" alt="截屏2020-12-28 上午10.38.09"></p>
</li>
</ul>
<h2 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h2><h3 id="重要概念-3"><a href="#重要概念-3" class="headerlink" title="重要概念"></a>重要概念</h3><h4 id="程序的装入-impotrant"><a href="#程序的装入-impotrant" class="headerlink" title="程序的装入 impotrant"></a>程序的装入 impotrant</h4><ul>
<li><p>绝对装入方式</p>
<p>程序编译之后生成绝对地址</p>
</li>
<li><p>可重定位装入方式</p>
<p>程序编译之后生成相对的地址</p>
</li>
<li><p>动态运行时装入方式</p>
<p>编译之后不立即转换为地址，而是在运行的时候转换</p>
</li>
</ul>
<h4 id="程序的链接-impotrant"><a href="#程序的链接-impotrant" class="headerlink" title="程序的链接 impotrant"></a>程序的链接 impotrant</h4><ul>
<li><p>静态链接方式</p>
<p>在程序运行之前，先将各个目标模块及他们所需的库函数连接成一个完整的装配模块</p>
</li>
<li><p>装入是动态链接</p>
<p>将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式</p>
</li>
<li><p>运行时动态链接</p>
<p>在需要某些模块的时候再进行链接</p>
</li>
</ul>
<h4 id="首次适应算法（FF）impotrant"><a href="#首次适应算法（FF）impotrant" class="headerlink" title="首次适应算法（FF）impotrant"></a>首次适应算法（FF）impotrant</h4><p>（基于顺序搜索）</p>
<p>在分配内存时，从链首开始顺序查找，直至找到一个大小能够满足要求的空闲分区为止</p>
<h4 id="循环首次适应算法（NF）impotrant"><a href="#循环首次适应算法（NF）impotrant" class="headerlink" title="循环首次适应算法（NF）impotrant"></a>循环首次适应算法（NF）impotrant</h4><p>（基于顺序搜索）</p>
<p>基本与FF相同，但是每次是从上一次找到的空闲分区的下一个空闲分区开始查找</p>
<h4 id="最佳适应算法（BF）impotrant"><a href="#最佳适应算法（BF）impotrant" class="headerlink" title="最佳适应算法（BF）impotrant"></a>最佳适应算法（BF）impotrant</h4><p>（基于顺序搜索）</p>
<p>容量从小到大形成空闲分区链，找到最合适的大小</p>
<h4 id="最坏适应算法（WF）impotrant"><a href="#最坏适应算法（WF）impotrant" class="headerlink" title="最坏适应算法（WF）impotrant"></a>最坏适应算法（WF）impotrant</h4><p>（基于顺序搜索）</p>
<p>每次都是找最大的空闲区</p>
<h4 id="快速适应算法"><a href="#快速适应算法" class="headerlink" title="快速适应算法"></a>快速适应算法</h4><p>（基于索引搜索的动态分区分配算法）</p>
<ul>
<li>根据进程的长度，从索引表中去寻找到能够容纳它的最小长度</li>
<li>从链表中取下第一块进行分配</li>
</ul>
<h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>（基于索引搜索的动态分区分配算法）</p>
<p>当需要为进程分配一个长度为 n 的存储空间时，首先计算一个 i 值，使 2i-1&lt;n≤2i，然 后在空闲分区大小为 2i 的空闲分区链表中查找。若找到，即把该空闲分区分配给进程。否 则，表明长度为 2i 的空闲分区已经耗尽，则在分区大小为 2i+1 的空闲分区链表中寻找。若 存在 2i+1 的一个空闲分区，则把该空闲分区分为相等的两个分区，这两个分区称为一对伙 伴，其中的一个分区用于分配，而把另一个加入分区大小为 2i 的空闲分区链表中。若大小 为 2i+1 的空闲分区也不存在，则需要查找大小为 2i+2 的空闲分区，若找到则对其进行两次分 割:第一次，将其分割为大小为 2i+1 的两个分区，一个用于分配，一个加入到大小为 2i+1 的空闲分区链表中;第二次，将第一次用于分配的空闲区分割为 2i 的两个分区，一个用于 分配，一个加入到大小为 2i 的空闲分区链表中。若仍然找不到，则继续查找大小为 2i+3 的 空闲分区，以此类推。由此可见，在最坏的情况下，可能需要对 2k 的空闲分区进行 k 次分 割才能得到所需分区。</p>
<h4 id="分页存储管理-important"><a href="#分页存储管理-important" class="headerlink" title="分页存储管理 important"></a>分页存储管理 important</h4><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%888.54.25.png" alt="截屏2020-12-28 上午8.54.25"></p>
<ul>
<li>P表示页号</li>
<li>A表示逻辑地址</li>
<li>L表示页面大小 （块大小）</li>
<li>d表示页内地址</li>
</ul>
<h4 id="分页存储的地址变换-important"><a href="#分页存储的地址变换-important" class="headerlink" title="分页存储的地址变换 important"></a>分页存储的地址变换 important</h4><p>逻辑地址 ====》物理地址</p>
<ol>
<li>先根据块的大小（页面大小），算出页号和页内地址</li>
<li>根据页号找到块号</li>
<li>物理地址 = 块号 x 页面大小（快的大小）+ 页内地址</li>
</ol>
<h4 id="块表-important"><a href="#块表-important" class="headerlink" title="块表 important"></a>块表 important</h4><p>普通查询方式<strong>至少两次</strong>访问内存</p>
<p>为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为“联想寄存器”(Associative Memory)，或称为“快表”</p>
<h4 id="分段存储管理"><a href="#分段存储管理" class="headerlink" title="分段存储管理"></a>分段存储管理</h4><p>优点</p>
<ul>
<li>方便编程</li>
<li>信息共享</li>
<li>信息保护</li>
<li>动态增长</li>
<li>动态链接</li>
</ul>
<h3 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h3><ul>
<li><p>何谓静态链接？何谓装入时动态链接和运行时的动态链接？</p>
<p>静态链接是指在程序运行前，先将各目标模块及它们所需的库函数，链接成一个完整的 装配模块，以后不再拆开的链接方式。 装入时动态链接是指将用户源程序编译后得到的一组目标模块，在装入内存时采用边装入边链接的链接方式。 运行时动态链接是指对某些目标模块的链接，是在程序执行中需要该目标模块时，才对 它进行的链接。 </p>
</li>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.42.48.png" alt="截屏2020-12-28 上午10.42.48"></p>
</li>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.43.05.png" alt="截屏2020-12-28 上午10.43.05"></p>
</li>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.43.22.png" alt="截屏2020-12-28 上午10.43.22"></p>
</li>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.43.37.png" alt="截屏2020-12-28 上午10.43.37"></p>
</li>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.44.05.png" alt="截屏2020-12-28 上午10.44.05"></p>
</li>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.44.21.png" alt="截屏2020-12-28 上午10.44.21"></p>
</li>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.44.37.png" alt="截屏2020-12-28 上午10.44.37"></p>
</li>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.44.56.png" alt="截屏2020-12-28 上午10.44.56"></p>
</li>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-28%20%E4%B8%8A%E5%8D%8810.45.27.png" alt="截屏2020-12-28 上午10.45.27"></p>
</li>
</ul>
<h2 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章 虚拟存储器"></a>第五章 虚拟存储器</h2><h3 id="重要概念-4"><a href="#重要概念-4" class="headerlink" title="重要概念"></a>重要概念</h3><h4 id="最佳（Optimal）置换算法-important"><a href="#最佳（Optimal）置换算法-important" class="headerlink" title="最佳（Optimal）置换算法 important"></a>最佳（Optimal）置换算法 important</h4><p>其所选择的被淘汰页面， 将是以后永不使用的，或许是在最长(未来)时间内不再被访问的页面</p>
<h4 id="先进先出（FIFO）页面置换算法-important"><a href="#先进先出（FIFO）页面置换算法-important" class="headerlink" title="先进先出（FIFO）页面置换算法 important"></a>先进先出（FIFO）页面置换算法 important</h4><p>该算法总是淘汰最先进入内存的页面，即选择在内存中驻 留时间最久的页面予以淘汰</p>
<h4 id="LRU置换算法（最近最久未使用算法）important"><a href="#LRU置换算法（最近最久未使用算法）important" class="headerlink" title="LRU置换算法（最近最久未使用算法）important"></a>LRU置换算法（最近最久未使用算法）important</h4><p>LRU 置换算法是选择最近最久未 使用的页面予以淘汰</p>
<h4 id="产生抖动的原因-important"><a href="#产生抖动的原因-important" class="headerlink" title="产生抖动的原因 important"></a>产生抖动的原因 important</h4><p>同时在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使每一个进程在运行时，频繁地出现缺页，必须请求系统将所缺之页调入内存</p>
<h4 id="抖动的预防方法-important"><a href="#抖动的预防方法-important" class="headerlink" title="抖动的预防方法 important"></a>抖动的预防方法 important</h4><ul>
<li>采用局部置换策略</li>
<li>把工作集算法融入到处理机调度中</li>
<li>利用“L = S”准则调节缺页率</li>
<li>选择暂停的进程</li>
</ul>
<h3 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h3><ul>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.06.19.png" alt="截屏2021-01-05 下午10.06.19"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.07.26.png" alt="截屏2021-01-05 下午10.07.26"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.07.44.png" alt="截屏2021-01-05 下午10.07.44"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.08.07.png" alt="截屏2021-01-05 下午10.08.07"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.08.26.png" alt="截屏2021-01-05 下午10.08.26"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.08.43.png" alt="截屏2021-01-05 下午10.08.43"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.09.00.png" alt="截屏2021-01-05 下午10.09.00"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.09.17.png" alt="截屏2021-01-05 下午10.09.17"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.09.31.png" alt="截屏2021-01-05 下午10.09.31"></li>
</ul>
<h2 id="第六章-输入输出系统"><a href="#第六章-输入输出系统" class="headerlink" title="第六章 输入输出系统"></a>第六章 输入输出系统</h2><h3 id="重要概念-5"><a href="#重要概念-5" class="headerlink" title="重要概念"></a>重要概念</h3><h4 id="I-O系统的基本功能"><a href="#I-O系统的基本功能" class="headerlink" title="I/O系统的基本功能"></a>I/O系统的基本功能</h4><ul>
<li>隐藏物理设备的细节</li>
<li>与设备的无关性</li>
<li>提高处理机和I/O设备的利用率</li>
<li>与I/O设备的正确共享</li>
<li>错误处理</li>
</ul>
<h4 id="I-O软件的层次"><a href="#I-O软件的层次" class="headerlink" title="I/O软件的层次"></a>I/O软件的层次</h4><ul>
<li>用户层I/O软件</li>
<li>设备独立性软件</li>
<li>设备驱动程序</li>
<li>中断处理程序</li>
</ul>
<h4 id="设备驱动程序的功能"><a href="#设备驱动程序的功能" class="headerlink" title="设备驱动程序的功能"></a>设备驱动程序的功能</h4><ul>
<li>接收由与设备无关的软件发来的命令和参数</li>
<li>检查用户I/O请求的合法性</li>
<li>发出I/O命令</li>
<li>及时响应由设备控制器发来的中断请求</li>
</ul>
<h4 id="假脱机（Spooling）系统-important"><a href="#假脱机（Spooling）系统-important" class="headerlink" title="假脱机（Spooling）系统 important"></a>假脱机（Spooling）系统 important</h4><p><strong>组成</strong></p>
<ul>
<li>输入井和输出井</li>
<li>输入缓冲区和输出缓冲区</li>
<li>输入进程和输出进程</li>
<li>井管理程序</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>提高了I/O的速度</li>
<li>将独占设备改造为共享设备</li>
<li>实现了虚拟设备功能</li>
</ul>
<h4 id="缓冲引入的原因"><a href="#缓冲引入的原因" class="headerlink" title="缓冲引入的原因"></a>缓冲引入的原因</h4><ul>
<li>缓和 CPU 与 I/O 设备间速度不匹配的矛盾</li>
<li>减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制</li>
<li>解决数据粒度不匹配问题</li>
<li>提高 CPU 和 I/O 设备之间的并行性</li>
</ul>
<h4 id="单缓冲区和双缓冲区-important"><a href="#单缓冲区和双缓冲区-important" class="headerlink" title="单缓冲区和双缓冲区 important"></a>单缓冲区和双缓冲区 important</h4><p><strong>单缓冲区</strong></p>
<p>对每一块数据的处理时间：Max(C, T) + M</p>
<p>C表示CPU对这块数据的处理时间</p>
<p>T表示输入的时间</p>
<p>M表示传送的时间</p>
<p>C与T是并行的</p>
<p><strong>双缓冲区</strong></p>
<p>对每一块数据的处理时间：Max(C, T)</p>
<h4 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h4><ul>
<li>寻道时间</li>
<li>旋转延迟时间</li>
<li>传输时间</li>
</ul>
<h4 id="先来先服务（FCFS）-important"><a href="#先来先服务（FCFS）-important" class="headerlink" title="先来先服务（FCFS） important"></a>先来先服务（FCFS） important</h4><p>（磁盘调度算法）</p>
<p>它根据进程请求访问磁盘的先后次序进行调度</p>
<h4 id="最短寻道时间优先（SSTF）important"><a href="#最短寻道时间优先（SSTF）important" class="headerlink" title="最短寻道时间优先（SSTF）important"></a>最短寻道时间优先（SSTF）important</h4><p>要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短</p>
<h4 id="扫描-SCAN-算法-important"><a href="#扫描-SCAN-算法-important" class="headerlink" title="扫描(SCAN)算法 important"></a>扫描(SCAN)算法 important</h4><p>坐电梯算法</p>
<p>该算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁头当前的移 动方向</p>
<h4 id="循环扫描（CSCAN）算法"><a href="#循环扫描（CSCAN）算法" class="headerlink" title="循环扫描（CSCAN）算法"></a>循环扫描（CSCAN）算法</h4><p>到最上面之后直接到最下</p>
<p>到最下面之后直接到最上</p>
<h3 id="习题-5"><a href="#习题-5" class="headerlink" title="习题"></a>习题</h3><ul>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.10.05.png" alt="截屏2021-01-05 下午10.10.05"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.10.46.png" alt="截屏2021-01-05 下午10.10.46"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.11.03.png" alt="截屏2021-01-05 下午10.11.03"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.11.17.png" alt="截屏2021-01-05 下午10.11.17"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.11.37.png" alt="截屏2021-01-05 下午10.11.37"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.11.48.png" alt="截屏2021-01-05 下午10.11.48"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.12.05.png" alt="截屏2021-01-05 下午10.12.05"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.12.21.png" alt="截屏2021-01-05 下午10.12.21"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.12.38.png" alt="截屏2021-01-05 下午10.12.38"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.12.57.png" alt="截屏2021-01-05 下午10.12.57"></li>
</ul>
<h2 id="第七章-文件管理"><a href="#第七章-文件管理" class="headerlink" title="第七章 文件管理"></a>第七章 文件管理</h2><h3 id="习题-6"><a href="#习题-6" class="headerlink" title="习题"></a>习题</h3><ul>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.13.49.png" alt="截屏2021-01-05 下午10.13.49"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.14.27.png" alt="截屏2021-01-05 下午10.14.27"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.14.57.png" alt="截屏2021-01-05 下午10.14.57"></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-05%20%E4%B8%8B%E5%8D%8810.15.17.png" alt="截屏2021-01-05 下午10.15.17"></li>
</ul>
<h2 id="第八章-磁盘存储器的管理"><a href="#第八章-磁盘存储器的管理" class="headerlink" title="第八章 磁盘存储器的管理"></a>第八章 磁盘存储器的管理</h2><h3 id="重要概念-6"><a href="#重要概念-6" class="headerlink" title="重要概念"></a>重要概念</h3><h4 id="外存的组织方式"><a href="#外存的组织方式" class="headerlink" title="外存的组织方式"></a>外存的组织方式</h4><ul>
<li>连续组织方法</li>
<li>连接组织方式</li>
<li>索引组织方式</li>
</ul>
<h4 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h4><p>可能会考计算题</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.zkwzkw.top/2021/01/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7%E8%A7%A3%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kaiwen zhou">
      <meta itemprop="description" content="the web page to share my code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meredith's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/01/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E6%9C%9F%E6%9C%AB%E8%AF%95%E5%8D%B7%E8%A7%A3%E6%9E%90/" class="post-title-link" itemprop="url">算法分析期末试卷解析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-01-02 17:07:43" itemprop="dateCreated datePublished" datetime="2021-01-02T17:07:43+08:00">2021-01-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="算法分析期末试卷解析"><a href="#算法分析期末试卷解析" class="headerlink" title="算法分析期末试卷解析"></a>算法分析期末试卷解析</h1><h2 id="代码托管地址"><a href="#代码托管地址" class="headerlink" title="代码托管地址"></a>代码托管地址</h2><p><a target="_blank" rel="noopener" href="https://github.com/Meredith2000/final_exam_of_algorithm_analysis">https://github.com/Meredith2000/final_exam_of_algorithm_analysis</a></p>
<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><blockquote>
<p>题目：用伪代码描述一个二分查找算法的完整过程</p>
<p>题目类型：二分法</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>下面是一个有序的列表，而红色背景的元素就是我们需要寻找的元素了</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%881.33.19.png" alt="截屏2020-12-19 下午1.33.19"></p>
<p><strong>注意：二分法查找要求列表中的值是有序的！！！</strong></p>
<p><strong>现在我们将列表中放入三个指针</strong>，他们分别是：</p>
<ul>
<li>指向列表头部的head指针 -&gt; 0</li>
<li>指向列表尾部的tail指针 -&gt; len(array)</li>
<li>指向列表中间的mid指针 -&gt; int(head + mid)</li>
</ul>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%881.41.14.png" alt="截屏2020-12-19 下午1.41.14"></p>
<p><strong>我们约定检索的规则如下：</strong></p>
<ul>
<li>如果mid所指的值等于我们所要寻找的值，那么就认为找到了</li>
<li>如果mid所指的值大于我们要寻找的值，那么我们寻找的值，一定在mid的左边，则移动tail指针到mid的左边，并重新计算mid</li>
<li>如果mid所指的值小于我们要寻找的值，那么我们寻找的值，一定在mid的右边，则移动head指针到mid的右边，并重新计算mid</li>
<li>如果head &gt; tail 那就说明列表中没有这个元素</li>
</ul>
<h3 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h3><p><strong>下面我们进行第一次的比较：</strong></p>
<p>​    此时mid所代表的的是6号元素，其所对应的值是7，由于7小于我们所要寻找的11，所以head指向7号元素，mid = (head + tail)/2，所以mid所指的是9号元素，其值为10，对应图如下</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%881.54.26.png" alt="截屏2020-12-19 下午1.54.26"></p>
<p><strong>下面我们进行第三次的比较：</strong></p>
<p>​    此时mid所代表的的是9号元素，其所对应的值是10，由于10小于我们所要寻找的11，所以head指向10号元素，mid = (head + tail)/2，所以mid所指的是11号元素，其值为12，对应图如下</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%881.58.07.png" alt="截屏2020-12-19 下午1.58.07"></p>
<p><strong>下面我们进行第四次的比较：</strong></p>
<p>​    此时mid所代表的的是11号元素，其所对应的值是12，由于12大于我们所要寻找的11，所以tail指向10号元素，mid = (head + tail)/2，所以mid所指的是10号元素，其值为11，对应图如下</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%882.01.37.png" alt="截屏2020-12-19 下午2.01.37"></p>
<p><strong>下面我们进行第五次比较：</strong></p>
<p>​    此时mid所代表的的是10号元素，其所对应的值是11，11正是我们要寻找的元素！</p>
<h3 id="etc"><a href="#etc" class="headerlink" title="etc"></a>etc</h3><p>此种算法的算法复杂度为<strong>O(log(2n))</strong></p>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><blockquote>
<p>题目：在2k*2k的棋盘覆盖问题中，如果k值等于3，残缺方块的行列序号分别是7和6，请给出此种状态下的覆盖过程描述并简单解释使用了何种算法以及本题使用这种算法的优势。</p>
<p>题目类型：分治法+递归</p>
</blockquote>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>如下图所示，红色部分表示缺失的棋盘位置：</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%882.23.47.png" alt="截屏2020-12-19 下午2.23.47"></p>
<p>面对这样的题，我们可以把整个棋盘分成4个子棋盘，分别是<strong>左上，右上，左下，右下</strong>，如下图：</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%882.41.44.png" alt="截屏2020-12-19 下午2.41.44"></p>
<p>可以看出确实的格子是属于左上的，所以我们要在其余没有缺少的子棋盘中的指定一个做为缺少的（指定位置），如下图：</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-19%20%E4%B8%8B%E5%8D%882.49.19.png" alt="截屏2020-12-19 下午2.49.19"></p>
<p>根据上面的过程可以不断的递归下去，每一个棋盘都可以分为四个子棋盘，直到最后只有一个格子的时候退出</p>
<h3 id="伪代码演示"><a href="#伪代码演示" class="headerlink" title="伪代码演示"></a>伪代码演示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play_chess</span>(<span class="params">棋盘的大小, 棋盘的顶点横坐标, 棋盘的顶点纵坐标, 缺少位置的横坐标, 缺少位置的纵坐标</span>):</span></span><br><span class="line">  <span class="comment"># 递归的出口</span></span><br><span class="line">  <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="comment"># 首先进行棋盘的分割</span></span><br><span class="line">  <span class="comment"># 左上角</span></span><br><span class="line">  <span class="keyword">if</span> 缺失的格子在左上角:</span><br><span class="line">    play_chess(棋盘位置调整到左上角，缩小规模)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    chess_board[中心点的左上方坐标] = trace_step</span><br><span class="line">    play_chess(棋盘位置调整到左上角, 缩小规模, 更新缺少的点)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 右上角</span></span><br><span class="line">  <span class="keyword">if</span> 缺失的格子在右上角:</span><br><span class="line">    play_chess(棋盘位置调整到右上角，缩小规模)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    chess_board[中心点的右上方坐标] = trace_step</span><br><span class="line">    play_chess(棋盘位置调整到右上角, 缩小规模, 更新缺少的点)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 左下角</span></span><br><span class="line">  <span class="keyword">if</span> 缺失的格子在左下角:</span><br><span class="line">    play_chess(棋盘位置调整到左下角，缩小规模)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    chess_board[中心点的左下方坐标] = trace_step</span><br><span class="line">    play_chess(棋盘位置调整到左下角, 缩小规模, 更新缺少的点)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 右下角</span></span><br><span class="line">  <span class="keyword">if</span> 缺失的格子在右下角:</span><br><span class="line">    play_chess(棋盘位置调整到右下角，缩小规模)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    chess_board[中心点的右下方坐标] = trace_step</span><br><span class="line">    play_chess(棋盘位置调整到右下角, 缩小规模, 更新缺少的点)</span><br></pre></td></tr></table></figure>
<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><blockquote>
<p>题目：给定n种物品和一个背包。物品i的重量为wi，其价值为vi,背包的容量为C。使用动态规划方法分析并描述应该如何选择装入背包的物品，使得装入背包中物品的总价值最大？在选择装入背包时，对每种物品只有两种选择：即装入背包或不装入背包，不能将物品装入背包多次，也不能只装入部分某物品。</p>
<p>题目类型：0，1背包问题（动态规划）</p>
</blockquote>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这是一道典型的动态规划的题目，主要是要写出整个的状态转义方程，其实对于整体而言，一直在重复拿和不拿之间的关系，即找到拿或者不拿中间的最大值</p>
<p>这里我把表中的取值的过程简单写成一个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value_table[i][j] = <span class="built_in">max</span>(拿的价值，不拿的价值)</span><br></pre></td></tr></table></figure>
<p><strong>状态转移方程：</strong><br>$$<br>value_table[i][j] =<br>\begin{cases}<br>value_table[i-1][j] \\<br>value[i] + value_table[i-1][j-weight[i]]<br>\end{cases}<br>$$<br>建立表格之后，找到最大的就行了</p>
<h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><blockquote>
<p>题目：在最长公共子序列问题中，用c[i][j]记录Xi和Yi的最长公共子序列的长度。其中，Xi={x1,x2…xi}，Yi={y1,y2…yi}。当i或j的值为0时，X和Y的最长公共子序列为空序列。请求出在一般情况下，由本问题的最优子结构性质所建立的递归关系式，给出推导过程。</p>
<p>题目类型：LCS 动态规划</p>
</blockquote>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>这是一道动态规划的题目，状态转移方程如下</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-25%20%E4%B8%8A%E5%8D%8810.29.44.png" alt="截屏2020-12-25 上午10.29.44"></p>
<p>跟上面一样，建立表格后找到最大的就可以</p>
<h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><blockquote>
<p>题目：设计一个贪心算法（详细的流程图，或者 完整的伪代码，或者 有注释的源代码）， 把一个真分数表示为埃及分数之和的形式。所谓埃及分数，是指分子为1的分数。如：7/8=1/2+1/3+1/24。</p>
<p>题目类型：贪心算法</p>
</blockquote>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>贪心算法的思想是：找到局部最优解，那么整体就会最优</p>
<p>在这道题中，要把一个真分数转换为尽量少的埃及真分数，那么每次的在取分数的时候都找它最大的埃及真分数就行了</p>
<p>在这道题中，我运用的暴力+贪心的算法，由于分母越小的分数，值越大，所以<strong>分母从2开始，不断地加1，直到比原来的数要小，然后这个数就是当前最大的埃及真分数了</strong></p>
<p>但是在做题的过程中，我看见网上有一种效率更加的高的方法，直接可以给出当前最大的埃及真分数，但是要用到数学方面的推倒，我这里就不做深究了，源码我放在了文件中，各位可以下下来运行。</p>
<h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><blockquote>
<p>题目：给定无向图G和m种不同的颜色，用这些颜色对图G的各顶点进行着色，每个顶点着一种颜色。分析是否有一种着色法使G中每条边的两个顶点着不同颜色？使用回溯法分析本问题，并画出在此框架下的解空间树（并添加适当注释）。</p>
<p>题目类型：回溯法</p>
</blockquote>
<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>回溯法实际上就是深度优先搜索+减枝</p>
<p>我们将问题简化一下，设置一下边界，就成了下面这个无向图</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8B%E5%8D%887.45.10.png" alt="截屏2020-12-29 下午7.45.10"></p>
<p>对于无向图的在电脑中的保存我使用了邻接矩阵的方式来存放</p>
<p>从1节点开始，有三种不同的颜色选择，形成了三个子节点，而这三个子节点又可以分别形成各自的三个不同的子节点，这样就形成了一个数，通过判断有没有颜色一样的来进行减枝，如下图</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2020-12-29%20%E4%B8%8B%E5%8D%887.45.03.png" alt="截屏2020-12-29 下午7.45.03"></p>
<h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><blockquote>
<p>题目：有一批共n个集装箱要装上两艘载重量分别为c1和c2的轮船，其中集装箱i的重量为wi，且集装箱总重量小于两艘船的载重总量。请确定是否有一个合理的装载方案可将所有的集装箱装上这两艘轮船。这是经典的装载问题，在此问题中，当我们将问题变换成本质上是研究如何将第一艘船尽可能装满后，在使用分支限界的方法时，是如何进行“分支限界”的？</p>
<p>题目类型：分支限界</p>
</blockquote>
<p>实际上分支限界就是广度优先搜索，类似于上一题回溯法，只有“取”和“不取”的两种状态</p>
<p>这里我通过简单的FIFO来广度优先遍历树，实际上FIFO算法就是一个队列，将队列中的头看作是根节点，从而衍生出多个子节点，在这道题中，每个节点都会有两个子节点，分别是“取”或者是“不取”，在确定子节点之后，将生成的两个子节点放入队列的末尾，知道队列中的长度为空，这个树就遍历结束了</p>
<p>通过设置分支限界可以有效减小问题的规模，这里有两个限界的点，第一个超过了船最大容量，我们称之为“上界”，这种只会发生在“取”的情况下，第二个是下面的所有物品中之和加上头结点不能大于现有最大的节点，这就说明下面就算是全取，也不可能大于现有的最优解，所以这个节点可以不入队。</p>
<h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><blockquote>
<p>题目：结合你在数据结构与算法课程中获取的知识，自行设计一种面向字符串的单个关键字查找算法，假定查找范围为普通的一维数组。要求：与之前我们所学的所有查找算法都不完全相同。使用详细的流程图，完整的伪代码，有注释的源代码，等其中的任意一种描述方法均可</p>
</blockquote>
<p>这道题，我的想法借鉴于哈夫曼编码的压缩算法，主要思想如下：</p>
<p>首先根据母串建立如下字典索引：</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-02%20%E4%B8%8B%E5%8D%884.51.41.png" alt="截屏2021-01-02 下午4.51.41"></p>
<p>在母串中的所有字母都会在字典中有一个key，而每个key所对应的value实际上是一个数组，这个数组中的值，就是在母串中出现的位置</p>
<p>在查找的时候，先找到子串中的第一个字符，并在字典中找到其对应的value数组，取到value数组之后，将之中的所有索引都分别+1，再与子串下一个字符对应的value数组进行比较，并只保留相同的部分，一直不断重读，知道子串遍历结束，或者两个之间没有重复的元素</p>
<p>最后得到的结果就表示着子串在母串中结尾字符的位置</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.zkwzkw.top/2020/12/29/c%E5%A4%B4%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kaiwen zhou">
      <meta itemprop="description" content="the web page to share my code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meredith's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/29/c%E5%A4%B4%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/" class="post-title-link" itemprop="url">Clion无法找到unistd.h这个头文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-29 09:51:41" itemprop="dateCreated datePublished" datetime="2020-12-29T09:51:41+08:00">2020-12-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Clion无法找到unistd-h这个头文件"><a href="#Clion无法找到unistd-h这个头文件" class="headerlink" title="Clion无法找到unistd.h这个头文件"></a>Clion无法找到unistd.h这个头文件</h1><blockquote>
<p>今天遇到一个很无语的错误，前几天一直在操作系统实习，里面用到了很多unistd.h 还有csignal中定义的一些变量，之前都是能够正常运行的。然后最近要演示代码，我就想打开程序再运行一下，结果一打开，疯狂爆红，然后我看了一下，根源居然是没有找到头文件！！晚上找了很多方法都是没有用的（什么叫你升级xcode都是扯淡），然后我将源码复制到xcode中去运行，结果居然运行成功了！我猜测可能的原因是我的xcode前段时间升级了一下，然后头文件的目录产生了变化，而clion还没有来得及更变目录，这里我提供一下临时的解决方案</p>
</blockquote>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>MacOS 11.1</li>
<li>Clion 2020.3</li>
<li>Xcode 12.3</li>
</ul>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>在cmake中在添加下面这个几行代码</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 链接库文件</span></span><br><span class="line"><span class="keyword">link_directories</span>(/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib)</span><br></pre></td></tr></table></figure>
<p>这里其实就是指定头文件的路径和链接库的路径，有点类似PATH</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.zkwzkw.top/2020/12/18/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kaiwen zhou">
      <meta itemprop="description" content="the web page to share my code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meredith's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/18/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">软件需求分析复习指北</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-12-18 21:59:26" itemprop="dateCreated datePublished" datetime="2020-12-18T21:59:26+08:00">2020-12-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="软件需求分析复习指北"><a href="#软件需求分析复习指北" class="headerlink" title="软件需求分析复习指北"></a>软件需求分析复习指北</h1><hr>
<h2 id="第一章-需求工程导论"><a href="#第一章-需求工程导论" class="headerlink" title="第一章 需求工程导论"></a>第一章 需求工程导论</h2><h3 id="软件项目的三种类型（P3）"><a href="#软件项目的三种类型（P3）" class="headerlink" title="软件项目的三种类型（P3）"></a>软件项目的三种类型（P3）</h3><ul>
<li>在预期的时间内，在预算的成本下完成预期的所有功能，则项目为成功项目</li>
<li>已经完成，软件产品能够正常工作，但在生产中或者超支，或者超期，或者实现的功能不全的项目为问题项目</li>
<li>因无法进行而被中途撤销，或者最终产品无法提交试用，则项目为失败项目</li>
</ul>
<h3 id="项目成功项目的因素（P4）"><a href="#项目成功项目的因素（P4）" class="headerlink" title="项目成功项目的因素（P4）"></a>项目成功项目的因素（P4）</h3><ul>
<li>用户参与</li>
<li>高层管理支持</li>
<li>清晰的需求说明</li>
<li>正确的项目计划</li>
<li>切合实际的期望</li>
<li>细化的项目里程碑</li>
<li>员工能力</li>
<li>主人翁意识</li>
<li>清晰的目标和前景</li>
<li>努力工作</li>
</ul>
<h3 id="影响问题项目的因素（P4）"><a href="#影响问题项目的因素（P4）" class="headerlink" title="影响问题项目的因素（P4）"></a>影响问题项目的因素（P4）</h3><ul>
<li>缺少用户的输入</li>
<li>不完整的需求说明</li>
<li>需求变化</li>
<li>缺乏高层管理支持</li>
<li>技术能力不足</li>
<li>缺乏资源</li>
<li>不切实际的期望</li>
<li>目标不清晰</li>
<li>不现实的时间要求</li>
<li>新技术的影响</li>
</ul>
<h3 id="影响失败项目的因素（P4）"><a href="#影响失败项目的因素（P4）" class="headerlink" title="影响失败项目的因素（P4）"></a>影响失败项目的因素（P4）</h3><ul>
<li>不完整的需求说明</li>
<li>缺少用户输入</li>
<li>缺乏资源</li>
<li>不切实际的期望</li>
<li>缺乏高层管理支持</li>
<li>需求变化</li>
<li>缺乏计划</li>
<li>额外的无用功能</li>
<li>缺乏IT管理</li>
<li>技术能力不足</li>
</ul>
<h3 id="软件模拟特性（P5）"><a href="#软件模拟特性（P5）" class="headerlink" title="软件模拟特性（P5）"></a>软件模拟特性（P5）</h3><p>​    导致需求问题的原因中最重要的原因就是：<strong>未能很好的理解和掌握“应用”型软件的模拟特性以及由此而产生的一系列影响和要求</strong><br>​    软件的模拟特性来源于其知识载体的特性：<strong>软件在运行中表现出来的特性，行为应该和应用的现实情况保持一致</strong>。这样，人们通过观察软件的表现就可以得出相应现实问题的答案，即软件“模拟”了现实</p>
<p>“模拟”性具体指</p>
<ul>
<li>目的性</li>
<li>正确性</li>
<li>现实可理解性</li>
</ul>
<h3 id="需求工程中基本的活动（P12）"><a href="#需求工程中基本的活动（P12）" class="headerlink" title="需求工程中基本的活动（P12）"></a>需求工程中基本的活动（P12）</h3><div class="mermaid">
graph TD
需求工程---需求开发
需求工程---需求管理
需求开发---需求获取
需求开发---需求分析
需求开发---需求规格说明
需求开发---需求需求验证
</div>

<h3 id="需求工程的复杂性（P16）"><a href="#需求工程的复杂性（P16）" class="headerlink" title="需求工程的复杂性（P16）"></a>需求工程的复杂性（P16）</h3><ul>
<li>处理范围广泛</li>
<li>涉及诸多参与方</li>
<li>处理内容多样</li>
<li>处理活动相互交织</li>
<li>处理结果要求苛刻</li>
</ul>
<h3 id="需求工程师需要具备的技能（P18）"><a href="#需求工程师需要具备的技能（P18）" class="headerlink" title="需求工程师需要具备的技能（P18）"></a>需求工程师需要具备的技能（P18）</h3><ul>
<li>熟练掌握软件开发的方法与技术</li>
<li>精确的表达能力和文档化能力</li>
<li>良好的沟通能力</li>
<li>抽象建模与分析能力</li>
<li>关系协调和团队工作的能力</li>
</ul>
<hr>
<h2 id="第二章-需求基础"><a href="#第二章-需求基础" class="headerlink" title="第二章 需求基础"></a>第二章 需求基础</h2><h3 id="问题解决的基础——模拟共享现象（P26）"><a href="#问题解决的基础——模拟共享现象（P26）" class="headerlink" title="问题解决的基础——模拟共享现象（P26）"></a>问题解决的基础——模拟共享现象（P26）</h3><p>处于问题域之外的解系统之所以能够解决问题域中问题，是因为<strong>问题域与解系统之间存在有效的互动，并在互动中相互影响</strong>。而问题域与解系统能够形成互动的基础是<strong>解系统部分模拟了问题域</strong>，这种模拟性称为共享现象</p>
<h3 id="需求和问题的层次（P28）"><a href="#需求和问题的层次（P28）" class="headerlink" title="需求和问题的层次（P28）"></a>需求和问题的层次（P28）</h3><ul>
<li><strong>业务需求</strong>，针对整个业务的期望</li>
<li><strong>用户需求</strong>，针对具体任务的期望</li>
<li><strong>系统级需求</strong>，针对用户与系统一次交互的期望</li>
</ul>
<div class="mermaid">
graph TD
业务需求--&gt;|业务需求指导需求获取|用户需求--&gt;|转化用户需求为系统级需求|系统需求

</div>

<h3 id="优秀需求的特性（P43）"><a href="#优秀需求的特性（P43）" class="headerlink" title="优秀需求的特性（P43）"></a>优秀需求的特性（P43）</h3><ul>
<li><p><strong>完备性</strong></p>
<p>需求是否描述了开发人员设计和实现这项功能所需的所有信息</p>
</li>
<li><p><strong>正确性</strong></p>
<p>每项需取样都必须正确描述所需要的系统功能，要真实反应用户的意图</p>
</li>
<li><p><strong>可行性</strong></p>
<p>需求必须能够在系统及其运行环境的已知条件和约束下实现</p>
</li>
<li><p><strong>必要性</strong></p>
<p>每一项需求都应该是必要的，它是满足用户的业务需求说必需的</p>
</li>
<li><p><strong>无歧义</strong></p>
<p>需求要能够正确传递的前提是传递者和受众能够形成共同的理解</p>
</li>
<li><p><strong>可验证</strong></p>
<p>需求是可以通过分析、检查、模拟或测试等方法能够判断需取样是否被满足</p>
</li>
</ul>
<hr>
<h2 id="第三章-需求工程过程"><a href="#第三章-需求工程过程" class="headerlink" title="第三章 需求工程过程"></a>第三章 需求工程过程</h2><h3 id="需求获取（P54）"><a href="#需求获取（P54）" class="headerlink" title="需求获取（P54）"></a>需求获取（P54）</h3><ul>
<li>收集背景资料</li>
<li>获取问题和目标，定义项目前景与范围</li>
<li>识别涉众，选择信息的来源</li>
<li>选择获取方法，执行获取，获取功能与非功能需求</li>
<li>记录获取结果</li>
</ul>
<h2 id="第四章-需求获取概述"><a href="#第四章-需求获取概述" class="headerlink" title="第四章 需求获取概述"></a>第四章 需求获取概述</h2><h3 id="需求获取中的常见困难（P75）"><a href="#需求获取中的常见困难（P75）" class="headerlink" title="需求获取中的常见困难（P75）"></a>需求获取中的常见困难（P75）</h3><ul>
<li>用户和开发人员的背景不同，立场不同<ul>
<li>知识理解的困难</li>
<li>默认知识现象</li>
</ul>
</li>
<li>普通用户缺乏概括性，综合性的表述能力</li>
<li>用户存在认知困难</li>
<li>用户越俎代庖<ul>
<li>用户提出的不是需求，而是解决方案</li>
<li>用户固执地坚持某些特征和功能</li>
</ul>
</li>
<li>缺乏用户参与<ul>
<li>用户数量太多，选择困难</li>
<li>用户认知不足，不愿意参与</li>
<li>用户情绪抵制，消极参与</li>
<li>没有明确的用户</li>
</ul>
</li>
</ul>
<h3 id="需求获取活动（P79）"><a href="#需求获取活动（P79）" class="headerlink" title="需求获取活动（P79）"></a>需求获取活动（P79）</h3><ul>
<li>研究应用背景，建立初始的知识框架</li>
<li>根据获取的需求，采用必要的获取方法和技巧</li>
<li>先行确定获取的内容和主题，设定场景</li>
<li>分析用户的高（深）层目标，理解用户的意图</li>
<li>进行涉众分析，针对涉众的特点展开工作</li>
</ul>
<h3 id="获取信息的内容（P80）"><a href="#获取信息的内容（P80）" class="headerlink" title="获取信息的内容（P80）"></a>获取信息的内容（P80）</h3><ul>
<li>需求</li>
<li>问题域描述</li>
<li>环境和约束</li>
</ul>
<h3 id="获取信息的来源（P81）"><a href="#获取信息的来源（P81）" class="headerlink" title="获取信息的来源（P81）"></a>获取信息的来源（P81）</h3><ul>
<li>涉众</li>
<li>硬数据</li>
<li>相关产品</li>
<li>重要文档</li>
<li>相关技术标准和法规</li>
</ul>
<h3 id="获取信息的方法（P81）"><a href="#获取信息的方法（P81）" class="headerlink" title="获取信息的方法（P81）"></a>获取信息的方法（P81）</h3><ul>
<li>传统方法<ul>
<li>问卷调差</li>
<li>面谈</li>
<li>文档分析</li>
<li>文档检查</li>
<li>需求剥离</li>
</ul>
</li>
<li>集体获取方法<ul>
<li>头脑风暴</li>
<li>专题讨论会</li>
<li>JAD（联合应用开发）</li>
<li>JRP（联合需求计划）</li>
</ul>
</li>
<li>原型<ul>
<li>采用原型方法</li>
</ul>
</li>
<li>模型驱动方法<ul>
<li>面对目标的方法</li>
<li>基于场景的方法</li>
<li>基于用例的方法</li>
</ul>
</li>
<li>认知方法<ul>
<li>任务分析</li>
<li>协议分析</li>
</ul>
</li>
<li>基于上下文的方法<ul>
<li>观察</li>
<li>民族志</li>
<li>话语分析</li>
</ul>
</li>
</ul>
<h3 id="获取信息的过程（P82）"><a href="#获取信息的过程（P82）" class="headerlink" title="获取信息的过程（P82）"></a>获取信息的过程（P82）</h3><ul>
<li><p><strong>注意事项</strong></p>
<ul>
<li>在整体上制定组织方案</li>
<li>维护项目的前景和范围</li>
<li>接受需求的不稳定性</li>
<li>控制探索性工作</li>
</ul>
</li>
<li><p><strong>防止遗漏需求</strong></p>
<ul>
<li>务必让所有涉众都表达自己的意见</li>
<li>不要以抽象和模糊的需求作为结束</li>
<li>使用多种方法表发需求信息</li>
<li>主义检查边界和布尔逻辑</li>
</ul>
</li>
<li><p><strong>结束获取</strong></p>
<ul>
<li>用户想不出更多的用例</li>
<li>用户想出的新用例都是导出用例</li>
<li>用户只是在重复已经讨论过的问题</li>
<li>新提出的特性、需求都在项目范围之外</li>
<li>新提出的需求优先级都很低</li>
<li>用户提出的新功能都属于后续版本，而非当前版本</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第五章-确定项目的前景与范围"><a href="#第五章-确定项目的前景与范围" class="headerlink" title="第五章 确定项目的前景与范围"></a>第五章 确定项目的前景与范围</h2><h3 id="问题分析（P96）"><a href="#问题分析（P96）" class="headerlink" title="问题分析（P96）"></a>问题分析（P96）</h3><ul>
<li><p><strong>获取问题</strong></p>
<ul>
<li>问题分析的前提是获取问题，这可以通过收集背景资料或与涉众沟通来实现</li>
</ul>
</li>
<li><p><strong>明确问题</strong></p>
<ul>
<li>对问题达成共识</li>
<li>收集背景资料，判断问题的明确性</li>
<li>分析不明确的问题，发现问题背后的问题</li>
</ul>
</li>
<li><p><strong>发现业务需求</strong></p>
<p>每一个明确、一致的问题都意味着涉众存在一些相应的期望目标，即业务需求</p>
</li>
<li><p><strong>定义问题解决方案及系统特性</strong></p>
<ul>
<li>建立问题解决方案</li>
<li>确定系统特性和解决方案的边界</li>
<li>确定解决方案的约束</li>
</ul>
</li>
</ul>
<h3 id="目标分析（P105）"><a href="#目标分析（P105）" class="headerlink" title="目标分析（P105）"></a>目标分析（P105）</h3><h3 id="活动图（P122）"><a href="#活动图（P122）" class="headerlink" title="活动图（P122）"></a>活动图（P122）</h3><h3 id="识别涉众的方法（P150）"><a href="#识别涉众的方法（P150）" class="headerlink" title="识别涉众的方法（P150）"></a>识别涉众的方法（P150）</h3><ul>
<li>先膨胀后收缩方法</li>
<li>检查列表方法</li>
<li>涉众网络方法</li>
</ul>
<h3 id="涉众评估（P156）"><a href="#涉众评估（P156）" class="headerlink" title="涉众评估（P156）"></a>涉众评估（P156）</h3><ul>
<li>优先级评估</li>
<li>风险评估</li>
<li>共赢分析</li>
</ul>
<h3 id="涉众代表选择（P160）"><a href="#涉众代表选择（P160）" class="headerlink" title="涉众代表选择（P160）"></a>涉众代表选择（P160）</h3><ul>
<li><strong>涉众代表选择</strong><ul>
<li>完整采样</li>
<li>态度积极</li>
<li>数量适中</li>
<li>比例恰当</li>
</ul>
</li>
<li><strong>用户替代源</strong><ul>
<li>拥有类似系统经验的系统分析人员</li>
<li>与用户直接联系的技术支持人员</li>
<li>服务咨询人员</li>
<li>内部或者外部的顾问</li>
<li>用户方的管理者</li>
<li>市场人员</li>
<li>拥有相关知识的开发人员</li>
</ul>
</li>
</ul>
<h3 id="硬数据及硬数据采样（P166）"><a href="#硬数据及硬数据采样（P166）" class="headerlink" title="硬数据及硬数据采样（P166）"></a>硬数据及硬数据采样（P166）</h3><ul>
<li>定制硬数据<ul>
<li>数据收集表格</li>
<li>统计报表</li>
</ul>
</li>
<li>定性硬数据<ul>
<li>整个组织的描述文件</li>
<li>业务指导文档</li>
<li>业务备忘</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第七章-基于用例-场景模型展开用户需求获取"><a href="#第七章-基于用例-场景模型展开用户需求获取" class="headerlink" title="第七章 基于用例/场景模型展开用户需求获取"></a>第七章 基于用例/场景模型展开用户需求获取</h2><h3 id="用例图（P186）"><a href="#用例图（P186）" class="headerlink" title="用例图（P186）"></a>用例图（P186）</h3><hr>
<h2 id="第十二章-过程建模"><a href="#第十二章-过程建模" class="headerlink" title="第十二章 过程建模"></a>第十二章 过程建模</h2><h3 id="数据流图（P293）"><a href="#数据流图（P293）" class="headerlink" title="数据流图（P293）"></a>数据流图（P293）</h3><hr>
<h2 id="第十三章-数据建模"><a href="#第十三章-数据建模" class="headerlink" title="第十三章 数据建模"></a>第十三章 数据建模</h2><hr>
<h2 id="第十六章-需求验证"><a href="#第十六章-需求验证" class="headerlink" title="第十六章 需求验证"></a>第十六章 需求验证</h2><h3 id="需求验证的方法（P418）"><a href="#需求验证的方法（P418）" class="headerlink" title="需求验证的方法（P418）"></a>需求验证的方法（P418）</h3><ul>
<li>需求评审</li>
<li>原型与模拟</li>
<li>开发测试用例</li>
<li>用户手册编制</li>
<li>利用跟踪关系</li>
<li>自动化分析</li>
</ul>
<hr>
<h2 id="第十七章-需求管理"><a href="#第十七章-需求管理" class="headerlink" title="第十七章 需求管理"></a>第十七章 需求管理</h2><h3 id="需求管理的作用（P431）"><a href="#需求管理的作用（P431）" class="headerlink" title="需求管理的作用（P431）"></a>需求管理的作用（P431）</h3><ul>
<li>增强了项目涉众对复杂产品特征在细节和互相依赖关系的理解</li>
<li>增进了项目涉众之间的交流</li>
<li>减少了工作量的浪费</li>
<li>准确反应项目的状态，帮助进行更好的项目决策</li>
<li>改变项目文化，使需求的作用得到重视和有效的发挥</li>
</ul>
<h3 id="需求管理的过程（P432）"><a href="#需求管理的过程（P432）" class="headerlink" title="需求管理的过程（P432）"></a>需求管理的过程（P432）</h3><ul>
<li>维护需求基线</li>
<li>实现需求跟踪</li>
<li>控制变更</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.zkwzkw.top/2020/11/27/%E7%BB%99express%E5%BC%80%E5%90%AFhttps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="kaiwen zhou">
      <meta itemprop="description" content="the web page to share my code">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meredith's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/11/27/%E7%BB%99express%E5%BC%80%E5%90%AFhttps/" class="post-title-link" itemprop="url">给Express开启HTTPS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-27 15:38:46" itemprop="dateCreated datePublished" datetime="2020-11-27T15:38:46+08:00">2020-11-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2020-12-12 21:55:33" itemprop="dateModified" datetime="2020-12-12T21:55:33+08:00">2020-12-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Nodejs/" itemprop="url" rel="index"><span itemprop="name">Nodejs</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>因为最近有一个项目放在express上跑，而且还必须要开启https，其实我一开始是先通过有ssl的nginx来反向代理没有证书的express，但是，经过我多方面的尝试，最终以失败告终，所以，我决定狠下心来，来给express配置安装ssl证书</p>
</blockquote>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>  CentOS 版本： 7.7</li>
<li>  express 版本：4.17.1</li>
<li>  node 版本： 14.15.1</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>  首先找到入口文件（一般是app.js），用vim打开</li>
<li>  配置以下信息</li>
</ul>
<p>// 导入依赖的模块<br>const express = require(‘express’)<br>const fs = require(‘fs’)<br>const https = require(‘https’)<br>// 找到ssl证书和秘钥<br>const privateCrt = fs.readFileSync(&lt;证书路径&gt;)<br>const privateKey = fs.readFileSync(&lt;秘钥路径&gt;)<br>// https的配置信息<br>const HTTPS_OPTOIN = {<br>  key: privateKey,<br>  cert: privateCrt<br>};<br>/*<br>*   你的代码逻辑<br>*/<br>// 生成服务器<br>const httpsServer = https.createServer(HTTPS_OPTOIN, app);<br>httpsServer.listen(&lt;你所定义的端口号&gt;);</p>
<ul>
<li>  启动服务</li>
</ul>
<h2 id="etc"><a href="#etc" class="headerlink" title="etc"></a>etc</h2><p>注意一定要将app配置好了之后再生成对应的https服务器，否则将会失败</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kaiwen zhou</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




<script>
if (document.querySelectorAll('.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js', () => {
    mermaid.init({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    }, '.mermaid');
  }, window.mermaid);
}
</script>


  





  


</body>
</html>
