<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="kaiwen zhou">


    <meta name="subtitle" content="share my code">


    <meta name="description" content="the web page to share my code">


    <meta name="keywords" content="code">




<title>算法分析复习 | Meredith&#39;s blog</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    







  <meta name="generator" content="Hexo 5.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">blog.zkwzkw.top</a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">
                            算法分析
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                算法分析复习
            
            
        </div>
        <span class="post-date">
            Jan 7, 2021
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h1 id="算法分析复习"><a href="#算法分析复习" class="headerlink" title="算法分析复习"></a>算法分析复习</h1><h2 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h2><p><a target="_blank" rel="noopener" href="https://github.com/Meredith2000/execrise_of_algorithm_analysis">https://github.com/Meredith2000/execrise_of_algorithm_analysis</a></p>
<h2 id="考试题型"><a href="#考试题型" class="headerlink" title="考试题型"></a>考试题型</h2><ul>
<li>基础知识 （50%）<ul>
<li>单向选择</li>
<li>判断</li>
</ul>
</li>
<li>分析应用<ul>
<li>分析题</li>
<li>应用题</li>
</ul>
</li>
</ul>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>提供后进先出方式的存取</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>先进先出方式的存取</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>使用指针，将数据块相连接</li>
<li>优点是插入快，删除快</li>
<li>缺点是查找慢</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li>优点是查找、插入、删除都快（如果树保持平衡）</li>
<li>缺点是删除算法复杂</li>
</ul>
<h3 id="红－黑树"><a href="#红－黑树" class="headerlink" title="红－黑树"></a>红－黑树</h3><ul>
<li>查找、插入、删除都快</li>
<li>树总是平衡的</li>
<li>缺点是算法复杂</li>
</ul>
<h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="什么是程序"><a href="#什么是程序" class="headerlink" title="什么是程序"></a>什么是程序</h3><p>程序＝数据结构＋算法</p>
<h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><p>算法是解一确定类问题的任意一种特殊的方法</p>
<h3 id="算法的五个重要特性"><a href="#算法的五个重要特性" class="headerlink" title="算法的五个重要特性"></a>算法的五个重要特性</h3><p>确定性、能行性、输入、输出、有穷性/有限性</p>
<h3 id="DCG"><a href="#DCG" class="headerlink" title="DCG"></a>DCG</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 辗转相除法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">bigger, smaller</span>):</span></span><br><span class="line">	<span class="keyword">while</span> bigger % smaller != <span class="number">0</span>:</span><br><span class="line">    temp = bigger % smaller</span><br><span class="line">    bigger = smaller</span><br><span class="line">    smaller = temp</span><br><span class="line">   <span class="keyword">return</span> smaller</span><br></pre></td></tr></table></figure>
<h3 id="算法分析的目的"><a href="#算法分析的目的" class="headerlink" title="算法分析的目的"></a>算法分析的目的</h3><p>通过对算法分析，在把算法变成程序实际运行前，就知道为完成一项任务所设计的算法的好坏，从而运行好算法，改进差算法，避免无益的人力和物力浪费</p>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p><strong>常见的多项式限界函数有：</strong></p>
<p><strong>Ο(1) &lt;</strong> <strong>Ο(logn) &lt;</strong> <strong>Ο(n) &lt;</strong> <strong>Ο(nlogn) &lt;</strong> <strong>Ο(n^2) &lt;</strong> <strong>Ο(n^3)</strong></p>
<p><strong>常见的多项式限界函数有：</strong></p>
<p><strong>Ο(2n) &lt;</strong> <strong>Ο(n！) &lt;</strong> <strong>Ο(n_n)</strong></p>
<h2 id="第二章-算法的基本工具"><a href="#第二章-算法的基本工具" class="headerlink" title="第二章 算法的基本工具"></a>第二章 算法的基本工具</h2><h2 id="第三章-蛮力法"><a href="#第三章-蛮力法" class="headerlink" title="第三章 蛮力法"></a>第三章 蛮力法</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>选择排序、冒泡排序、插入排序、顺序查找、朴素的字符串匹配、枚举法、盲目搜索算法</strong></p>
<h2 id="第四章-贪婪法"><a href="#第四章-贪婪法" class="headerlink" title="第四章 贪婪法"></a>第四章 贪婪法</h2><h3 id="贪婪法的思想"><a href="#贪婪法的思想" class="headerlink" title="贪婪法的思想"></a>贪婪法的思想</h3><p>贪婪算法通过一系列的局部选择来得到一个问题的解。所作的每一个选择都是当前状态下“最优”的选择。</p>
<p>只顾眼前，不管将来</p>
<h3 id="贪婪法获得最优解的条件"><a href="#贪婪法获得最优解的条件" class="headerlink" title="贪婪法获得最优解的条件"></a>贪婪法获得最优解的条件</h3><p>拥有以下两个性质：</p>
<ul>
<li><strong>贪心选择性质</strong><ul>
<li>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到</li>
</ul>
</li>
<li><strong>最优子结构性质</strong><ul>
<li>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</li>
</ul>
</li>
</ul>
<h3 id="计划安排"><a href="#计划安排" class="headerlink" title="计划安排"></a>计划安排</h3><p>见github中的plan.py</p>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-03%20%E4%B8%8A%E5%8D%881.19.46.png" alt="截屏2021-01-03 上午1.19.46"></p>
<h3 id="为什么0-1背包问题不能用贪心算法得到最优解"><a href="#为什么0-1背包问题不能用贪心算法得到最优解" class="headerlink" title="为什么0-1背包问题不能用贪心算法得到最优解?"></a>为什么0-1背包问题不能用贪心算法得到最优解?</h3><p><strong>对于0-1背包问题，贪心选择之所以不能得到最优解是因为在这种情况下，它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包的价值降低了</strong></p>
<h2 id="第五章-动态规划"><a href="#第五章-动态规划" class="headerlink" title="第五章 动态规划"></a>第五章 动态规划</h2><h3 id="动态规划的基本思想"><a href="#动态规划的基本思想" class="headerlink" title="动态规划的基本思想"></a>动态规划的基本思想</h3><p>把求解的问题分成许多阶段或多个子问题，然后按顺序求解各子问题。最后一个子问题就是初始问题的解。</p>
<p><strong>动态规划=贪婪策略+递推(降阶)+存储递推结果</strong></p>
<h3 id="动态规划算法的问题及决策应该具有两个性质"><a href="#动态规划算法的问题及决策应该具有两个性质" class="headerlink" title="动态规划算法的问题及决策应该具有两个性质"></a>动态规划算法的问题及决策应该具有两个性质</h3><ul>
<li><strong>最优化原理</strong><ul>
<li>最佳原则、最优子结构</li>
</ul>
</li>
<li><strong>无后向性</strong><ul>
<li>某阶段状态一旦确定以后，就不受这个状态以后决策的影响。即某状态以后的过程不会影响以前的状态，只与当前状态有关</li>
</ul>
</li>
</ul>
<h3 id="n个矩阵连乘问题"><a href="#n个矩阵连乘问题" class="headerlink" title="n个矩阵连乘问题"></a>n个矩阵连乘问题</h3><p>状态转移方程：</p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-03%20%E4%B8%8B%E5%8D%881.17.42.png" alt="截屏2021-01-03 下午1.17.42"></p>
<p>具体代码见仓库</p>
<h3 id="数塔问题"><a href="#数塔问题" class="headerlink" title="数塔问题"></a>数塔问题</h3><p>这里我采用的逆序法，从上到下，选择大的（具体代码见github）</p>
<h2 id="第六章-分治算法"><a href="#第六章-分治算法" class="headerlink" title="第六章 分治算法"></a>第六章 分治算法</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>将整个问题分解成若干个小问题后分而治之，如果分解得到的子问题相对来说还太大，则可反复使用分治策略将这些子问题分成更小的同类型子问题，直至产生出方便求解的子问题，必要时逐步合并这些子问题的解，从而得到问题的解。</p>
<h3 id="同题异策－-“算法”-与“策略”"><a href="#同题异策－-“算法”-与“策略”" class="headerlink" title="同题异策－ “算法” 与“策略”"></a>同题异策－ “算法” 与“策略”</h3><ul>
<li>策略<ul>
<li>一种思想，提出解决问题的思路</li>
<li>从战略高度上面向问题</li>
</ul>
</li>
<li>算法<ul>
<li>对一个/类具体问题的解决方法</li>
<li>面向具体实现，可以用任何方式描述</li>
<li>策略对算法有指导性</li>
<li>在一种策略的指导下，可以有多种不同的算法实现（如排序问题，使用贪婪策略，列出3种有效算法）</li>
</ul>
</li>
</ul>
<h3 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h3><p>见代码仓库</p>
<h3 id="不同算法之间的区别"><a href="#不同算法之间的区别" class="headerlink" title="不同算法之间的区别"></a>不同算法之间的区别</h3><ul>
<li>迭代(递推) <ul>
<li>中心思想：重复使用迭代(递推)公式，根据变量的旧值推出新值；</li>
<li>适用问题：具有明确迭代公式的问题，主要是数值计算等。</li>
</ul>
</li>
<li>贪婪<ul>
<li>中心思想：通过一系列的局部选择来得到一个问题的解，所作的每一步选择：“只顾眼前最优，不管将来好坏” ；</li>
<li>适用问题：<br>1)贪婪选择性质；<br>2)最优子结构性质。</li>
</ul>
</li>
<li>动态规划<ul>
<li>中心思想：把求解的问题分成许多阶段/子问题，然后按顺序求解各阶段/子问题；记录每个阶段决策得到的结果序列。最后阶段的解就是初始问题的解。</li>
<li>适用问题：<br>1)最优子结构； (必须有)<br>2)无后向性；<br>3)子问题重叠性质。 (体现优势)</li>
</ul>
</li>
<li>分治<ul>
<li>中心思想：将整个问题分解成若干个小问题后分而治之；分解，解决，合并。</li>
<li>适用问题：<br>1)问题的规模缩小到一定程度就可容易解决；<br>2)问题可以分解为若干个规模较小的相似问题；<br>3)子问题的解可以合并为原问题的解；<ol start="4">
<li>子问题相互独立</li>
</ol>
</li>
</ul>
</li>
<li>枚举<ul>
<li>中心思想：枚举出问题的所有可行解，找出其中的最优解</li>
<li>适用问题：其它策略难以奏效。</li>
</ul>
</li>
</ul>
<h2 id="第七章-图的搜索"><a href="#第七章-图的搜索" class="headerlink" title="第七章 图的搜索"></a>第七章 图的搜索</h2><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-03%20%E4%B8%8B%E5%8D%883.50.08.png" alt="截屏2021-01-03 下午3.50.08"></p>
<h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-03%20%E4%B8%8B%E5%8D%883.50.43.png" alt="截屏2021-01-03 下午3.50.43"></p>
<h3 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h3><p>当要求解的问题需要在n 个元素的子集中进行搜索，其搜索空间树被称作子集树(subset tree)</p>
<p>这n个元素都在子集中或被选取记为1，不在子集中或被舍去记为0，这样搜索空间为：</p>
<p>(0,0,……,0,0),</p>
<p> (0,0,……,0,1),</p>
<p> (0,0,……,1,0),</p>
<p> (0,0,……,1,1), </p>
<p> ……</p>
<p> (1,1,……,1,1)。</p>
<h3 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h3><p>当要求解的问题需要在n个元素的排列中搜索问题的解时，解空间树被称作排列树(permutation tree)</p>
<p>第一个元素有n 种选择，第二个元素有n-1种选择，第三个元素有n-2种选择，……，第n个元素有1种选择，共计n!个状态。若表示为树形就是一个n度树，这样的树有n! 个叶结点，所以每一个遍历树中所有节点的算法都必须耗时O(n! ) </p>
<p>搜索空间为：</p>
<p> (1,2,3,……,n-1,n),</p>
<p> (2,1,3,……,n-1,n),</p>
<p> (2,3,1,……,n-1,n),</p>
<p> (2,3,4,1,……,n-1,n),</p>
<p> …….</p>
<p> (n,n-1,……,3,2,1)</p>
<h3 id="隐式图"><a href="#隐式图" class="headerlink" title="隐式图"></a>隐式图</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%882.32.51.png" alt="截屏2021-01-07 下午2.32.51"></p>
<h3 id="显示图"><a href="#显示图" class="headerlink" title="显示图"></a>显示图</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%882.34.37.png" alt="截屏2021-01-07 下午2.34.37"></p>
<h2 id="第八章-回溯法"><a href="#第八章-回溯法" class="headerlink" title="第八章 回溯法"></a>第八章 回溯法</h2><h3 id="回溯法的基本思想"><a href="#回溯法的基本思想" class="headerlink" title="回溯法的基本思想"></a>回溯法的基本思想</h3><p>回溯法的基本做法是搜索，按深度优先策略，从根结点出发搜索解空间树，算法搜索至解空间树的任意一点时，先判断该结点是否包含问题的解。如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯；否则，进入该子树，继续按深度优先策略搜索。</p>
<p><strong>走不通，就掉头</strong></p>
<h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><p>见代码仓库</p>
<h3 id="最优装载回溯法"><a href="#最优装载回溯法" class="headerlink" title="最优装载回溯法"></a>最优装载回溯法</h3><p>见代码仓库</p>
<h3 id="重排原理"><a href="#重排原理" class="headerlink" title="重排原理"></a>重排原理</h3><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-01-07%20%E4%B8%8B%E5%8D%883.10.22.png" alt="截屏2021-01-07 下午3.10.22"></p>
<h2 id="第九章-分支限界法"><a href="#第九章-分支限界法" class="headerlink" title="第九章 分支限界法"></a>第九章 分支限界法</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>分支搜索法是一种在问题解空间上进行搜索尝试的算法</strong></p>
<p><strong>“分支”是采用广度优先的策略</strong></p>
<h3 id="最优装载问题"><a href="#最优装载问题" class="headerlink" title="最优装载问题"></a>最优装载问题</h3><p><strong>策略：</strong></p>
<ul>
<li>首先将第一艘轮船尽可能装满</li>
<li>将剩余的集装箱装上第二艘轮船。</li>
</ul>
<p>具体见我期末试卷分析</p>
<p><strong>装载上限</strong>：其后将当前最优解作为一个“界”，对上界（或下界）不可能达到（大于）这个界的分支则不去进行搜索，这样就缩小搜索范围，提高了搜索效率</p>
<p><strong>上界函数</strong>：<strong>当前载重量cw+剩余集装箱的重量&lt;=当前最优载重量bestw</strong></p>
<p><strong>FIFO和优先队列式分支限界法——LC-检索的区别</strong>：</p>
<p><strong>由于FIFO搜索或LIFO搜索是盲目地扩展结点，当前最优解距真正的最优解距离较大，作为“界”所起到的剪枝作用很有限，不能有效提高搜索速度。</strong></p>
<p><strong>LC分支-限界算法用堆存储活结点，以保证比较优良的结点先被扩展。且对于LC分支-限界算法，一旦扩展到叶结点就已经找到最优解，可以停止搜索。</strong></p>
<p>采用大根堆，将bestw最大的作为E-节点，当队列空或者是到叶子节点就结束循环</p>
<h3 id="铺线问题"><a href="#铺线问题" class="headerlink" title="铺线问题"></a>铺线问题</h3><p>见代码仓库</p>
<h2 id="第十章-概率算法"><a href="#第十章-概率算法" class="headerlink" title="第十章 概率算法"></a>第十章 概率算法</h2><p>见我代码仓库</p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2021/01/08/%E7%AE%97%E6%B3%95ppt/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2021/01/06/os%E8%80%83%E7%82%B9/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://hexo.io/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

  </body>
</html>
