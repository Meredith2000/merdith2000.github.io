<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="kaiwen zhou">


    <meta name="subtitle" content="share my code">


    <meta name="description" content="the web page to share my code">


    <meta name="keywords" content="code">




<title>软件体系结构复习 | Meredith&#39;s blog</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    







  <meta name="generator" content="Hexo 5.3.0"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">blog.zkwzkw.top.</a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">
                            软件体系结构
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                软件体系结构复习
            
            
        </div>
        <span class="post-date">
            Jun 8, 2021
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h1 id="软件体系结构复习"><a href="#软件体系结构复习" class="headerlink" title="软件体系结构复习"></a>软件体系结构复习</h1><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><ul>
<li>选择（30‘）</li>
<li>简答（20’）</li>
<li>分析</li>
<li>设计</li>
</ul>
<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="软件危机是什么（软件危机具体的表现）"><a href="#软件危机是什么（软件危机具体的表现）" class="headerlink" title="软件危机是什么（软件危机具体的表现）"></a>软件危机是什么（软件危机具体的表现）</h3><ul>
<li>软件成本日益增长</li>
<li>开发进度难以控制</li>
<li>软件质量差</li>
<li>软件维护困难</li>
</ul>
<h3 id="软件危机的原因（去年考过选择）"><a href="#软件危机的原因（去年考过选择）" class="headerlink" title="软件危机的原因（去年考过选择）"></a>软件危机的原因（去年考过选择）</h3><ul>
<li>用户需求不明确</li>
<li>缺乏正确的理论指导</li>
<li>软件规模越做越大</li>
<li>软件复杂度越来越高</li>
</ul>
<h3 id="如何克服软件危机"><a href="#如何克服软件危机" class="headerlink" title="如何克服软件危机"></a>如何克服软件危机</h3><p>人们面对的不单是技术问题，更重要的还是管理问题</p>
<p><strong>软件工程包括三要素</strong>：</p>
<ul>
<li><p><strong>方法</strong></p>
<p>  软件工程方法为软件开发提供了“如何做”的技术，是完成软件工程项目的技术手段。</p>
</li>
<li><p><strong>工具</strong></p>
<p>  软件工具是人们在开发软件的活动中智力和体力的扩展和延伸，为软件工程方法提供了自动的或半自动的软件支撑环境。</p>
</li>
<li><p><strong>过程</strong></p>
<p>  软件工程过程则是将软件工程的方法和工具综合起来以达到合理、及时地进行计算机软件开发的目的。</p>
</li>
</ul>
<h3 id="构件的定义"><a href="#构件的定义" class="headerlink" title="构件的定义"></a>构件的定义</h3><p><strong>构件是具有一定的功能，能够独立工作或能同其它构件装配起来协调工作的程序体，构件的使用同他的开发、 生产无关。</strong></p>
<h3 id="主流的构件模型流派（去年考过选择）"><a href="#主流的构件模型流派（去年考过选择）" class="headerlink" title="主流的构件模型流派（去年考过选择）"></a>主流的构件模型流派（去年考过选择）</h3><ul>
<li>OMG(Object Management Group，对象管理组织)的<strong>CORBA</strong> (Common Object Request Broker Architecture，通用对象请求代理结构)</li>
<li>Sun的<strong>EJB</strong> (Enterprise Java Bean)</li>
<li>Microsoft的<strong>DCOM</strong>(Distributed Component Object Model，分布式构件对象模型)</li>
</ul>
<h3 id="构件获取的途径"><a href="#构件获取的途径" class="headerlink" title="构件获取的途径"></a>构件获取的途径</h3><ul>
<li>从现有构件中获得符合要求的构件，直接使用或作适应性(flexibility)修改，得到可重用的构件。</li>
<li>通过遗留工程(legacy engineering)，将具有潜在重用价值的构件提取出来，得到可重用的构件。</li>
<li>从市场上购买现成的商业构件，即COTS(Commercial Off-The-Shell)构件。</li>
<li>开发新的符合要求的构件。</li>
</ul>
<h3 id="可重用技术对构件库组织方法的要求是（去年考过简答）"><a href="#可重用技术对构件库组织方法的要求是（去年考过简答）" class="headerlink" title="可重用技术对构件库组织方法的要求是（去年考过简答）"></a>可重用技术对构件库组织方法的要求是（去年考过简答）</h3><ul>
<li><strong>支持构件库的各种维护动作</strong>，如增加、删除以及修改构件，尽量不要影响构件库的结构。</li>
<li>不仅要支持精确匹配，还要支持<strong>相似构件的查找</strong>。</li>
<li>不仅能进行简单的<strong>语法匹配</strong>，而且能够查找在<strong>功能或行为方面等价或相似的构件</strong>。</li>
<li>对应用领域具有较强的描述能力和较好的<strong>描述精度</strong>。</li>
<li>库管理员和用户<strong>容易使用</strong>。</li>
</ul>
<h3 id="构件的分类方法"><a href="#构件的分类方法" class="headerlink" title="构件的分类方法"></a>构件的分类方法</h3><ul>
<li>关键字分类法</li>
<li>刻面分类法</li>
<li>超文本组织方法</li>
</ul>
<h3 id="如果把软件系统看成是构件的集合，那么从构件的外部形态来看，构成一个系统的构件可分为5类"><a href="#如果把软件系统看成是构件的集合，那么从构件的外部形态来看，构成一个系统的构件可分为5类" class="headerlink" title="如果把软件系统看成是构件的集合，那么从构件的外部形态来看，构成一个系统的构件可分为5类"></a>如果把软件系统看成是构件的集合，那么从构件的外部形态来看，构成一个系统的构件可分为5类</h3><ul>
<li>独立而成熟的构件</li>
<li>有限制的构件</li>
<li>适应性构件</li>
<li>装配的构件</li>
<li>可修改的构件</li>
</ul>
<h3 id="构件重用工作"><a href="#构件重用工作" class="headerlink" title="构件重用工作"></a>构件重用工作</h3><ul>
<li>检索与提取构件</li>
<li>理解与评价构件</li>
<li>修改构件</li>
<li>构件组装<ul>
<li><strong>基于功能的组装技术</strong></li>
<li><strong>基于数据的组装技术</strong></li>
<li><strong>面向对象的组装技术</strong></li>
</ul>
</li>
</ul>
<h3 id="软件体系结构的定义（去年考过简答）"><a href="#软件体系结构的定义（去年考过简答）" class="headerlink" title="软件体系结构的定义（去年考过简答）"></a>软件体系结构的定义（去年考过简答）</h3><p>软件体系结构为软件系统提供了一个<strong>结构、行为和属性的高级抽象</strong>，由<strong>构成系统的元素的描述</strong>、<strong>这些元素的相互作用</strong>、<strong>指导元素集成的模式</strong>以及<strong>这些模式的约束</strong>组成。软件体系结构不仅指定了系统的组织结构和拓扑结构，并且显示了系统需求和构成系统的元素之间的对应关系，提供了一些设计决策的基本原理。</p>
<h3 id="软件体系结构的意义（作用）（去年考过简答）"><a href="#软件体系结构的意义（作用）（去年考过简答）" class="headerlink" title="软件体系结构的意义（作用）（去年考过简答）"></a>软件体系结构的意义（作用）（去年考过简答）</h3><ul>
<li>体系结构是风险承担者进行交流的手段</li>
<li>体系结构是早期设计决策的体现</li>
<li>软件体系结构是可传递和可重用的模型</li>
</ul>
<h3 id="体系结构所经历的四个阶段"><a href="#体系结构所经历的四个阶段" class="headerlink" title="体系结构所经历的四个阶段"></a>体系结构所经历的四个阶段</h3><ul>
<li><p><strong>无体系结构设计阶段</strong></p>
<p>以汇编语言进行小规模应用程序开发为特征。</p>
</li>
<li><p><strong>萌芽阶段</strong></p>
<p>出现了程序结构设计主题，以控制流图和数据流图构成软件结构为特征。</p>
</li>
<li><p><strong>初期阶段</strong></p>
<p>出现了从不同侧面描述系统的结构模型，以UML为典型代表。</p>
</li>
<li><p><strong>高级阶段</strong></p>
<p>以描述系统的高层抽象结构为中心，不关心具体的建模细节，划分了体系结构模型与传统软件结构的界限，该阶段以Kruchten提出的“4+1”模型为标志。</p>
</li>
</ul>
<h2 id="第二章-软件体系建模"><a href="#第二章-软件体系建模" class="headerlink" title="第二章 软件体系建模"></a>第二章 软件体系建模</h2><h3 id="软件体系结构模型（jdkgg-jdk哥哥）"><a href="#软件体系结构模型（jdkgg-jdk哥哥）" class="headerlink" title="软件体系结构模型（jdkgg jdk哥哥）"></a>软件体系结构模型（jdkgg jdk哥哥）</h3><ul>
<li>结构模型</li>
<li>框架模型</li>
<li>动态模型</li>
<li>过程模型</li>
<li>功能模型</li>
</ul>
<h3 id="4-1视图模型（去年考过选择，两个）"><a href="#4-1视图模型（去年考过选择，两个）" class="headerlink" title="4+1视图模型（去年考过选择，两个）"></a>4+1视图模型（去年考过选择，两个）</h3><ul>
<li>逻辑视图<ul>
<li>逻辑视图(logic view)主要支持系统的功能需求，即系统提供给最终用户的服务</li>
</ul>
</li>
<li>开发视图<ul>
<li>开发视图(development view)也称模块视图(module view)，主要侧重于软件模块的组织和管理。</li>
</ul>
</li>
<li>进程视图<ul>
<li>进程视图(process view)也称为并发视图，侧重于系统的运行特性，主要关注一些非功能性 的需求，例如系统的性能和可用性。</li>
</ul>
</li>
<li>物理视图<ul>
<li>理视图(physical view)主要考虑如何把软件映射到硬件上，它通常要考虑到系统性能、规模、可靠性等。解决系统拓扑结构、系统安装、通讯等问题。</li>
</ul>
</li>
<li>场景视图<ul>
<li>场景(scenarios)可以看作是那些重要系统活动的抽象，它使四个视图有机联系起来，从某种 意义上说场景是最重要的需求抽象。</li>
</ul>
</li>
</ul>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-06-02%20%E4%B8%8B%E5%8D%882.30.35.png" alt="截屏2021-06-02 下午2.30.35"></p>
<h3 id="软件体系结构中的核心模型的五个元素（要素）（去年考过）"><a href="#软件体系结构中的核心模型的五个元素（要素）（去年考过）" class="headerlink" title="软件体系结构中的核心模型的五个元素（要素）（去年考过）"></a>软件体系结构中的核心模型的五个元素（要素）（去年考过）</h3><ul>
<li><p><strong>构件</strong></p>
<ul>
<li><strong>构件是具有某种功能的可重用的软件模板单元，表示了系统中主要的计算元素和数据存储。</strong>构件有两种:复合构件和原子构件，复合构件由其他复合构件和原子构件通过连接而成;原子构件是不可再分的构件，底层由实现该构件的类组成，这种构件的划分提供了体系结构的分层表示能力，有助于简化体系结构的设计。</li>
</ul>
</li>
<li><p><strong>连接件</strong></p>
<ul>
<li><strong>连接件表示了构件之间的交互</strong>，简单的连接件如:管道(pipe)、过程调用(procedure call)、事件广播(event broadcast)等，更为复杂的交互如:客户-服务器(client-server)通信协议，数据库和应用之间的SQL连接等。</li>
</ul>
</li>
<li><p><strong>配置</strong></p>
<ul>
<li><strong>配置表示了构件和连接件的拓扑逻辑和约束。</strong></li>
</ul>
</li>
<li><p><strong>端口</strong></p>
<ul>
<li><strong>表示构件和外部环境的交互点</strong></li>
</ul>
</li>
<li><p><strong>角色</strong></p>
<ul>
<li><strong>定义了该连接件表示的交互的参与者</strong></li>
</ul>
</li>
</ul>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-06-02%20%E4%B8%8B%E5%8D%881.57.16.png" alt="截屏2021-06-02 下午1.57.16"></p>
<h3 id="软件体系结构结构的生命周期模型的阶段"><a href="#软件体系结构结构的生命周期模型的阶段" class="headerlink" title="软件体系结构结构的生命周期模型的阶段"></a>软件体系结构结构的生命周期模型的阶段</h3><ul>
<li>软件体系结构的<strong>非形式化描述</strong></li>
<li>软件体系结构的<strong>规范描述和分析</strong></li>
<li>软件体系结构的<strong>求精及其验证</strong></li>
<li>软件体系结构的<strong>实施</strong></li>
<li>软件体系结构的<strong>演化和扩展</strong></li>
<li>软件体系结构的<strong>提供、评价和度量</strong></li>
<li>软件体系结构的<strong>终结</strong></li>
</ul>
<h3 id="软件开发的阶段"><a href="#软件开发的阶段" class="headerlink" title="软件开发的阶段"></a>软件开发的阶段</h3><ul>
<li>需求分析阶段</li>
<li>建立软件体系结构阶段</li>
<li>设计阶段</li>
<li>实现阶段</li>
<li>测试阶段</li>
</ul>
<h2 id="第三章-软件体系结构风格"><a href="#第三章-软件体系结构风格" class="headerlink" title="第三章 软件体系结构风格"></a>第三章 软件体系结构风格</h2><h3 id="软件体系风格的定义"><a href="#软件体系风格的定义" class="headerlink" title="软件体系风格的定义"></a>软件体系风格的定义</h3><p><strong>软件体系结构风格是描述某一特定应用领域中，系统组织方式的惯用模式</strong>。体系结构风格定义了一个系统家族，即一个体系结构定义一个词汇表和一组1约束。词汇表中包含一些构件和连接件类型，而这组约束指出系统是如何将这些构件和连接件组合起来的。 <strong>体系结构风格反映了该领域中众多系统所共有的结构和语义特性</strong></p>
<h3 id="软件体系结构风格的四要素（词语分配）"><a href="#软件体系结构风格的四要素（词语分配）" class="headerlink" title="软件体系结构风格的四要素（词语分配）"></a>软件体系结构风格的四要素（词语分配）</h3><ul>
<li>提供一个词汇表</li>
<li>定义一套配置规则</li>
<li>定义一套语义解释原则</li>
<li>定义对基于这种风格的系统所进行的分析</li>
</ul>
<h3 id="经典软件体系结构风格以及优缺点（分层的优点考过选择）"><a href="#经典软件体系结构风格以及优缺点（分层的优点考过选择）" class="headerlink" title="经典软件体系结构风格以及优缺点（分层的优点考过选择）"></a>经典软件体系结构风格以及优缺点（分层的优点考过选择）</h3><ul>
<li><p><strong>经典体系结构风格</strong></p>
<ul>
<li><strong>数据流风格</strong>:批处理序列、管道与过滤器。</li>
<li><strong>调用/返回风格</strong>:主程序与子程序、面向对象风格、层次结构。</li>
<li><strong>独立构件风格</strong>:进程通讯、事件系统。 </li>
<li><strong>虚拟机风格</strong>:解释器、基于规则的系统。</li>
<li><strong>仓库风格</strong>:数据库系统、超文本系统、黑板系统。</li>
</ul>
</li>
<li><p><strong>管道与过滤器</strong></p>
<ul>
<li><p><strong>优点</strong></p>
<ol>
<li>使得软构件具有良好的<strong>隐蔽性</strong>和<strong>高内聚、低耦合</strong>的特点。 </li>
<li>允许设计师将<strong>整个系统的输入/输出行为看成是多个过滤器的行为的简单合成</strong></li>
<li><strong>支持软件重用</strong>。只要提供适合在两个过滤器之间传送的数据，任何两个过滤器都可被连接起来。</li>
<li><strong>系统维护和增强系统性能简单</strong>。新的过滤器可以添加到现有系统中来;旧的可以被改进的过滤器替换掉。</li>
<li><strong>允许对一些如吞吐量、死锁等属性的分析。</strong></li>
<li><strong>支持并行执行</strong>。每个过滤器是作为一个单独的任务完成，因此可与其它任务并行执行。 </li>
</ol>
</li>
<li><p><strong>缺点</strong></p>
<ol>
<li><strong>通常导致进程成为批处理的结构</strong>。这是因为虽然过滤器可增量式地处理数据，但它们是独立的，所以设计师必须将每个过滤器看成一个完整的从输入到输出的转换。</li>
<li><strong>不适合处理交互的应用</strong>。当需要增量地显示改变时，这个问题尤为严重。 </li>
<li>因为在数据传输上<strong>没有通用的标准</strong>，每个过滤器都增加了解析和合成数据的工作，这样就导致了系统性能下降，并增加了编写过滤器的复杂性。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>数据抽象和面对对象系统</strong></p>
<ul>
<li><strong>优点</strong><ul>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-06-03%20%E4%B8%8B%E5%8D%889.20.53.png" alt="截屏2021-06-03 下午9.20.53"></li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-06-03%20%E4%B8%8B%E5%8D%889.22.07.png" alt="截屏2021-06-03 下午9.22.07"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基于事件的系统</strong></p>
<ul>
<li><strong>优点</strong><ol>
<li><strong>为软件重用提供了强大的支持</strong>。当需要将一个构件加入现存系统中时，只需将它注册到系 统的事件中。</li>
<li><strong>为改进系统带来了方便</strong>。当用一个构件代替另一个构件时，不会影响到其它构件的接口。</li>
</ol>
</li>
<li><strong>缺点</strong><ul>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-06-03%20%E4%B8%8B%E5%8D%889.22.51.png" alt="截屏2021-06-03 下午9.22.51"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>分层系统（去年选择）</strong></p>
<ul>
<li><strong>优点</strong><ol>
<li><strong>支持基于抽象程度递增的系统设计</strong>，使设计师可以把一个复杂系统按递增的步骤进行分解。</li>
<li><strong>支持功能增强</strong>，因为每一层至多和相邻的上下层交互，因此功能的改变最多影响相邻的上下层。</li>
<li><strong>支持重用</strong>。只要提供的服务接口定义不变，同一层的不同实现可以交换使用。这样，就可 以定义一组标准的接口，而允许各种不同的实现方法。</li>
</ol>
</li>
<li><strong>缺点</strong><ol>
<li><strong>并不是每个系统都可以很容易地划分为分层的模式</strong>，甚至即使一个系统的逻辑结构是层次 化的，出于对系统性能的考虑，系统设计师不得不把一些低级或高级的功能综合起来;</li>
<li><strong>很难找到一个合适的、正确的层次抽象方法。</strong></li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-06-03%20%E4%B8%8B%E5%8D%889.23.45.png" alt="截屏2021-06-03 下午9.23.45"></li>
</ol>
</li>
</ul>
</li>
<li><p>仓库系统及知识库</p>
<ul>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-06-03%20%E4%B8%8B%E5%8D%889.24.19.png" alt="截屏2021-06-03 下午9.24.19"></li>
</ul>
</li>
<li><p>数据共享风格</p>
<ul>
<li><p>优点</p>
<ul>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-06-03%20%E4%B8%8B%E5%8D%889.25.35.png" alt="截屏2021-06-03 下午9.25.35"></li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-06-03%20%E4%B8%8B%E5%8D%889.25.54.png" alt="截屏2021-06-03 下午9.25.54"></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-06-03%20%E4%B8%8B%E5%8D%889.26.10.png" alt="截屏2021-06-03 下午9.26.10"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>C2风格</strong></p>
<ul>
<li><strong>优点</strong></li>
</ul>
<ol>
<li><p><strong>系统中的构件可实现应用需求，并能将任意复杂度的功能封装在一起。</strong> </p>
</li>
<li><p><strong>所有构件之间的通讯是通过以连接件为中介的异步消息交换机制来实现的。</strong></p>
</li>
<li><p><strong>构件相对独立，构件之间依赖性较少。</strong>系统中不存在某些构件将在同一地址空间内执行，或某些构件共享特定控制线程之类的相关性假设。</p>
</li>
</ol>
<ul>
<li><strong>缺点</strong>（网上答案）<ol>
<li><strong>效率低</strong>，若业务处理涉及多个构件层次，在系统执行过程中将存在性能损耗</li>
<li><strong>层次不清</strong>，难以划分出合适的，正确的层次结构，有时由于需求，需要跨层交互，增加复杂性</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="客户-服务器风格的任务"><a href="#客户-服务器风格的任务" class="headerlink" title="客户/服务器风格的任务"></a>客户/服务器风格的任务</h3><ul>
<li><strong>服务器负责有效地管理系统的资源，其任务集中于:</strong><ul>
<li>数据库安全性的要求</li>
<li>数据库访问并发性的控制</li>
<li>数据库前端的客户应用程序的全局数据完整性规则</li>
<li>数据库的备份与恢复</li>
</ul>
</li>
<li><strong>客户应用程序的主要任务是:</strong><ul>
<li>提供用户与数据库交互的界面</li>
<li>向数据库服务器提交用户请求并接收来自数据库服务器的信息</li>
<li>利用客户应用程序对存在于客户端的数据执行应用逻辑要求</li>
</ul>
</li>
</ul>
<h3 id="客户-服务器（C-S）风格的优缺点"><a href="#客户-服务器（C-S）风格的优缺点" class="headerlink" title="客户/服务器（C/S）风格的优缺点"></a>客户/服务器（C/S）风格的优缺点</h3><ul>
<li>优点<ul>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-06-03%20%E4%B8%8B%E5%8D%889.27.21.png" alt="截屏2021-06-03 下午9.27.21"></li>
</ul>
</li>
<li>缺点<ul>
<li><strong>开发成本较高</strong>。C/S 体系结构对客户端软硬件配置要求较高，尤其是软件的不断升级，对 硬件要求不断提高，增加了整个系统的成本，且客户端变得越来越臃肿。</li>
<li><strong>客户端程序设计复杂</strong>。采用C/S体系结构进行软件开发，大部分工作量放在客户端的程序 设计上，客户端显得十分庞大。</li>
<li><strong>信息内容和形式单一</strong>，因为传统应用一般为事务处理，界面基本遵循数据库的字段解释， 开发之初就已确定，而且不能随时截取办公信息和档案等外部信息，用户获得的只是单纯的字符和 数字，既枯燥又死板。</li>
<li><strong>用户界面风格不一</strong>，使用繁杂，不利于推广使用。</li>
<li><strong>软件移植困难</strong>。采用不同开发工具或平台开发的软件，一般互不兼容，不能或很难移植到 其它平台上运行。</li>
<li><strong>软件维护和升级困难</strong>。采用C/S体系结构的软件要升级，开发人员必须到现场为客户机升级，每个客户机上的软件都需维护。对软件的一个小小改动(例如只改动一个变量)，每一个客户端都必须更新。</li>
<li><strong>新技术不能轻易应用</strong>。因为一个软件平台及开发工具一旦选定，不可能轻易更改。</li>
</ul>
</li>
<li>二层的缺点<ul>
<li>二层C/S结构是单一服务器且以局域网为中心的，所以难以扩展至大型企业广域网或 Internet。</li>
<li>软、硬件的组合及集成能力有限。 (3)客户机的负荷太重，难以管理大量的客户机，系统的性能容易变坏。</li>
<li>数据安全性不好。因为客户端程序可以直接访问数据库服务器，那么，在客户端计算机上的其他程序也可想办法访问数据库服务器，从而使数据库的安全性受到威胁。</li>
</ul>
</li>
</ul>
<h3 id="三层C-S结构中的中间件"><a href="#三层C-S结构中的中间件" class="headerlink" title="三层C/S结构中的中间件"></a>三层C/S结构中的中间件</h3><p>在三层C/S体系结构中，<strong>中间件是最重要的构件</strong>。所谓中间件是一个用API定义的软件层，是具 有强大通信能力和良好可扩展性的分布式软件管理框架。它的功能是在客户机和服务器或者服务器 和服务器之间传送数据，实现客户机群和服务器群之间的通信。其工作流程是:在客户机里的应用 程序需要驻留网络上某个服务器的数据或服务时，搜索此数据的C/S应用程序需访问中间件系统。该 系统将查找数据源或服务，并在发送应用程序请求后重新打包响应，将其传送回应用程序。</p>
<h3 id="三层C-S的优缺点（去年考过简答）"><a href="#三层C-S的优缺点（去年考过简答）" class="headerlink" title="三层C/S的优缺点（去年考过简答）"></a>三层C/S的优缺点（去年考过简答）</h3><ul>
<li>允许合理地划分三层结构的功能，使之在逻辑上保持相对独立性，从而使整个系统的逻辑 结构更为清晰，能提高系统和软件的可维护性和可扩展性。</li>
<li>允许更灵活有效地选用相应的平台和硬件系统，使之在处理负荷能力上与处理特性上分别 适应于结构清晰的三层;并且这些平台和各个组成部分可以具有良好的可升级性和开放性。例如， 最初用一台Unix工作站作为服务器，将数据层和功能层都配置在这台服务器上。随着业务的发展， 用户数和数据量逐渐增加，这时，就可以将Unix工作站作为功能层的专用服务器，另外追加一台专 用于数据层的服务器。若业务进一步扩大，用户数进一步增加，则可以继续增加功能层的服务器数 目，用以分割数据库。清晰、合理地分割三层结构并使其独立，可以使系统构成的变更非常简单。 因此，被分成三层的应用基本上不需要修正。</li>
<li>三层C/S结构中，应用的各层可以并行开发，各层也可以选择各自最适合的开发语言。使 之能并行地而且是高效地进行开发，达到较高的性能价格比;对每一层的处理逻辑的开发和维护也 会更容易些。</li>
<li>允许充分利用功能层有效地隔离开表示层与数据层，未授权的用户难以绕过功能层而利用 数据库工具或黑客手段去非法地访问数据层，这就为严格的安全管理奠定了坚实的基础;整个系统 的管理层次也更加合理和可控制。</li>
</ul>
<p>值得注意的是:三层C/S结构各层间的通信效率若不高，即使分配给各层的硬件能力很强，其作 为整体来说也达不到所要求的性能。此外，设计时必须慎重考虑三层间的通信方法、通信频度及数 据量。这和提高各层的独立性一样是三层C/S结构的关键问题。</p>
<p><strong>PPT版本</strong></p>
<p><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-06-03%20%E4%B8%8B%E5%8D%8810.17.54.png" alt="截屏2021-06-03 下午10.17.54"></p>
<h3 id="浏览器服务器（B-S）优缺点（重要）"><a href="#浏览器服务器（B-S）优缺点（重要）" class="headerlink" title="浏览器服务器（B/S）优缺点（重要）"></a>浏览器服务器（B/S）优缺点（重要）</h3><ul>
<li><p>优点</p>
<ul>
<li>B/S体系结构主要是利用不断成熟的WWW浏览器技术，结合浏览器的多种脚本语言，用通用浏 览器就实现了原来需要复杂的专用软件才能实现的强大功能，并节约了开发成本。从某种程度上来 说，B/S结构是一种全新的软件体系结构。</li>
<li>在B/S结构中，除了数据库服务器外，应用程序以网页形式存放于Web服务器上，用户运行某个应用程序时只须在客户端上的浏览器中键入相应的网址，调用Web服务器上的应用程序并对数据库 进行操作完成相应的数据处理工作，最后将结果通过浏览器显示给用户。可以说，在B/S模式的计算 机应用系统中，应用(程序)在一定程度上具有集中特征。</li>
<li>基于B/S体系结构的软件，系统安装、修改和维护全在服务器端解决。用户在使用系统时，仅仅 需要一个浏览器就可运行全部的模块，真正达到了“零客户端”的功能，很容易在运行时自动升 级。B/S体系结构还提供了异种机、异种网、异种应用服务的联机、联网、统一服务的最现实的开放 性基础。</li>
<li>B/S结构出现之前，管理信息系统的功能覆盖范围主要是组织内部。B/S结构的“零客户端”方 式，使组织的供应商和客户(这些供应商和客户有可能是潜在的，也就是说可能是事先未知的!) 的计算机方便地成为管理信息系统的客户端，进而在限定的功能范围内查询组织相关信息，完成与 组织的各种业务往来的数据交换和处理工作，扩大了组织计算机应用系统的功能覆盖范围，可以更 加充分利用网络上的各种资源，同时应用程序维护的工作量也大大减少。另外，B/S结构的应用系统 与Internet的结合也使新的企业应用(例如，电子商务、客户关系管理等)的实现成为可能。</li>
<li>成本低、维护方便、 分布性强、开发简单（网上答案）</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>B/S体系结构<strong>缺乏对动态页面的支持能力</strong>，没有集成有效的数据库处理功能。</li>
<li>B/S体系结构的系统<strong>扩展能力差</strong>，<strong>安全性难以控制</strong>。 </li>
<li>采用B/S体系结构的应用系统，在数据查询等<strong>响应速度</strong>上，要远远地低于C/S体系结构。 </li>
<li>B/S体系结构的数据提交一般以页面为单位，<strong>数据的动态交互性不强</strong>，不利于在线事务处理(OnLine Transaction Processing，OLTP)应用。</li>
</ul>
</li>
</ul>
<h3 id="黑板系统（老师没划重点，但是去年考过选择）"><a href="#黑板系统（老师没划重点，但是去年考过选择）" class="headerlink" title="黑板系统（老师没划重点，但是去年考过选择）"></a>黑板系统（老师没划重点，但是去年考过选择）</h3><p>组成部分</p>
<ul>
<li>知识源</li>
<li>黑板数据结构</li>
<li>控制</li>
</ul>
<h2 id="第四章-软件体系结构描述"><a href="#第四章-软件体系结构描述" class="headerlink" title="第四章 软件体系结构描述"></a>第四章 软件体系结构描述</h2><h3 id="软件体系结构描述方法（文，数，图）"><a href="#软件体系结构描述方法（文，数，图）" class="headerlink" title="软件体系结构描述方法（文，数，图）"></a>软件体系结构描述方法（文，数，图）</h3><ul>
<li><strong>文字</strong>表达工具</li>
<li><strong>数学</strong>表达工具</li>
<li><strong>图形</strong>表达工具</li>
</ul>
<h3 id="ADL与其他语言的比较"><a href="#ADL与其他语言的比较" class="headerlink" title="ADL与其他语言的比较"></a>ADL与其他语言的比较</h3><ul>
<li><strong>构造能力</strong>指的是ADL能够使用较小的独立体系结构元素来建造大型软件系统;</li>
<li><strong>抽象能力</strong>指的是ADL使得软件体系结构中的构件和连接件描述可以只关注它们的抽象特 性，而不管其具体的实现细节;</li>
<li><strong>重用能力</strong>指的是ADL使得组成软件系统的构件、连接件甚至是软件体系结构都成为软件系 统开发和设计的可重用部件;</li>
<li><strong>组合能力</strong>指的是ADL使得其描述的每一系统元素都有其自己的局部结构，这种描述局部结 构的特点使得ADL支持软件系统的动态变化组合;</li>
<li><strong>异构能力</strong>指的是ADL允许多个不同的体系结构描述关联存在;</li>
<li><strong>分析和推理能力</strong>指的是ADL允许对其描述的体系结构进行多种不同的性能和功能上的多种 推理分析。</li>
<li><img src="https://public-meredith.oss-cn-beijing.aliyuncs.com/uPic/%E6%88%AA%E5%B1%8F2021-06-03%20%E4%B8%8B%E5%8D%8810.28.51.png" alt="截屏2021-06-03 下午10.28.51"></li>
</ul>
<p>P111</p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ul>
<li>顺序图</li>
<li>类图</li>
<li>通信图</li>
<li>构件图</li>
</ul>
<h2 id="第六章-可扩展标记语言"><a href="#第六章-可扩展标记语言" class="headerlink" title="第六章 可扩展标记语言"></a>第六章 可扩展标记语言</h2><p>XML</p>
<h2 id="第七章-动态软件体系结构"><a href="#第七章-动态软件体系结构" class="headerlink" title="第七章 动态软件体系结构"></a>第七章 动态软件体系结构</h2><h3 id="体系结构动态性的三类"><a href="#体系结构动态性的三类" class="headerlink" title="体系结构动态性的三类"></a>体系结构动态性的三类</h3><ul>
<li>交互式动态性</li>
<li>结构化动态性</li>
<li>体系结构动态性</li>
</ul>
<h3 id="动态体系结构的形式化表述方法（去年选择）"><a href="#动态体系结构的形式化表述方法（去年选择）" class="headerlink" title="动态体系结构的形式化表述方法（去年选择）"></a>动态体系结构的形式化表述方法（去年选择）</h3><ul>
<li>图形化方法</li>
<li>进程代数方法</li>
<li>逻辑化描述方法</li>
</ul>
<h3 id="动态软件体系结构描述语言"><a href="#动态软件体系结构描述语言" class="headerlink" title="动态软件体系结构描述语言"></a>动态软件体系结构描述语言</h3><ul>
<li>Dynamic Wright</li>
<li>Darwin</li>
</ul>
<h3 id="动态体系结构的特征"><a href="#动态体系结构的特征" class="headerlink" title="动态体系结构的特征"></a>动态体系结构的特征</h3><ul>
<li>可构造性</li>
<li>适应性</li>
<li>智能性</li>
</ul>
<h2 id="十一章"><a href="#十一章" class="headerlink" title="十一章"></a>十一章</h2><h3 id="软件质量评估属性（去年考过选择）"><a href="#软件质量评估属性（去年考过选择）" class="headerlink" title="软件质量评估属性（去年考过选择）"></a>软件质量评估属性（去年考过选择）</h3><ul>
<li>性能</li>
<li>可靠性</li>
<li>可用性</li>
<li>安全性</li>
<li>可修改性（准确来说是考了这个点）<ul>
<li>可维护性</li>
<li>可扩展性</li>
<li>结构重组</li>
<li>可移植性</li>
</ul>
</li>
<li>功能性</li>
<li>可变性</li>
<li>集成性</li>
<li>互操作性</li>
</ul>
<h3 id="评估的主要方法"><a href="#评估的主要方法" class="headerlink" title="评估的主要方法"></a>评估的主要方法</h3><ul>
<li>基于调查问卷或检查表的评估方式</li>
<li>基于场景的评估方式</li>
<li>基于度量的评估方式</li>
</ul>
<h3 id="ATAM"><a href="#ATAM" class="headerlink" title="ATAM"></a><strong>ATAM</strong></h3><ul>
<li>描述ATAM方法</li>
<li>描述业务动机</li>
<li>描述体系结构</li>
<li>确定体系结构方法</li>
<li>生成质量属性效用树</li>
<li>分析体系结构方法</li>
<li>讨论和分级场景</li>
<li>分析体系结构方法</li>
<li>描述评估结果</li>
</ul>
<h3 id="SAAM"><a href="#SAAM" class="headerlink" title="SAAM"></a><strong>SAAM</strong></h3><ul>
<li>形成场景</li>
<li>描述体系结构</li>
<li>对场景进行分类和确定优先级</li>
<li>对间接场景的单个评估</li>
<li>评估场景的相互作用</li>
<li>形成总体评估</li>
<li>SAAM评估日程安排</li>
</ul>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2021/03/26/%E8%88%AA%E7%A9%BA%E9%80%89%E5%BA%A7%E9%97%AE%E9%A2%98%E8%BF%9B%E8%A1%8C%E7%89%B9%E5%BE%81%E5%80%BC%E6%8F%90%E5%8F%96/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://hexo.io/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

  </body>
</html>
